\chapter{Eksempler}

\section{Hajer og fisk på Wator} Som eksempel på en \des har vi valgt at tage 
udgangspunkt i det scenarie som A. K. Dewdney
beskrev i artiklen \cite{wator}. \fixme[inline]{reference}. Artiklen beskriver 
den
fiktive planet Wator, der har form som en torus og er fuldstændig
dækket af vand. Verdenen er inddelt i felter som beskrevet på side
20 i \fixme[inline]{ref}. Disse felter kan være tomme, indeholde en
fisk eller en haj. Følgende karakteristika beskriver fisk og hajers
opførsel.


Fisk - bevæger sig og forplanter sig Lever af plankton, en ressource
som er uendelig. Hvis der er et ledigt tilstødende felt bevæger en
fisk sig til dette felt. Hvis der er flere ledige felter vælges et
tilfældigt. Hvis en fisk overlever 3 livscykler forplanter den sig.


Hajer - jager og forplanter sig Såfremt der er fisk i et eller flere
tilstødende felter flytter hajen sig herhen og spiser fisken. Hvis der
er flere tilstødende felter med fisk vælges et tilfældigt. Er der
ikke nogen fisk i nærheden bevæger en haj sig på samme måde som en
fisk. Hvis en haj ikke spiser i mere end 3 livscykler dør den. Hvis en
haj overlever 10 livscykler forplanter den sig.

For hvert tidsskridt vil alle fisk og hajer udføre en handling ud fra
ovenstående opførsel.

Til at initiere systemet skal der defineres en størrelse af verdenen,
samt hvor mange fisk og hajer der er til stede fra start. Disse fisk og
hajer placeres tilfældigt i verdenen.

Såfremt de initielle parametre understøtter en bæredygtig bestand
forventer vi at se bestanden af henholdsvis fisk og hajer oscillerer
afhængigt af hinanden.


\section{uden tid}
For at simulere Wator verdenen i et CSP-system hvori tidsbegrebet ikke er 
introduceret, er vi nødt til at udføre en synkronisering af de enkelte 
processers arbejde. Initielt skal vi bestemme hvad en proces skal arbejde 
repræsentere. Dette kan være en enkelt fisk eller haj, en proces for fisk og en 
for hajer, eller en opdeling af verdenen i dele der styres af processer.
Baseret på Peter Welch's\fixme[inline]{ref, artikel om crew}




\section{Kunder i en bank} Et klassisk eksempel inden for \des er at simulere  
en række kunder der alle ankommer til en butik, hvor de skal serviceres. Dette 
simple problem kan bruges til at modellere mange forskellige 
problemstillinger, som hvordan flowet ændrer sig hvis man varier en parameter 
i systemet. Programmeringssproget SimPy har som et af deres eksempel, en 
simulering af kunder i en bank. SimPy bruger dette som en gennemgående 
eksempler hvor de løbende udvider deres model for at vise forskellige 
egenskaber ved deres model. For at nemt at kunne sammenligne SimPy  med vores 
model vil vi bruge dette eksempel.

I det simple tilfælde af eksemplet ankommer der en kunde til banken på på et 
tilfældigt tidspunkt. Hun opholder sig i banken i et tidsrum, hvorefter hun 
igen forlader banken.

I det simple eksempel kan der ikke uddrages meget information, da banken ikke 
består af en begrænset ressource som kunderne skal tilgå.  Eksemplet er derfor 
også udvidet med en service disk, hvor alle kunderne skal betjenes af en 
servicemedarbejder. Alle kunder ankommer til banken i tilfældig orden og 
stiller sig i kø til at blive serviceret. Dette  svare til en M/M/1\fixme{hvad  
er en m/m/1 kø} kø.


\section{Eksisterende PYCSP}
For at modellere eksemplet med kunder i en bank i PyCSP, skal der foretages en række valg. Først og fremmest skal det besluttes hvad der skal være processer, og hvordan  kanalerne skal forbindes. 
I DES findes der i modsætningen til PDES \fixme{referencer} en global tid og alle processerne skal derfor have  en fælles tid der tæller op samtidigt. Den en brugt metode er at  bruge en barrier \vref{barrier}.

\begin{lstlisting}[label=barrier,caption=A barrier in PyCSP]
@process
def Barrier(nprocesses, signalIN, signalOUT):
	while True:
		for i in range (nprocesses):
			signalIN()
		for i in range (nprocesses):
			signalOUT(0)
\end{lstlisting}

Barrier blev introduceret i MPI, og sikrer at alle tråde har nået dette punkt før de må fortsætte. 
I PyCSP er det trivielt at have  denne egenskab, da processer til begge kanalender er klar, og med to kanaler kan man sikre at ingen proces modtager et signal før alle processer har sendt et signal til barrieren.

I SimPy er hver customer en process og det vil være nærliggende at 


