\section{Repræsentation af tid}
\fxnote{dette skal gennemlæses for logisk tid ifh. til deadline osv.}
I PyCSP foregår kommunikation kun når begge kanalender er klar dvs.
når der findes både en kanalende der vil skrive og en kanalende der vil læse. 
Hvis kun en af kanalenderne er klar, vil den vente indtil
der findes minumum en kanalende af hver type, der er klar. I alternation 
findes muligheden for at tilknytte en timeout til en guard. Dette
giver muligheden for at en process, kun er villig til at vente på at kanalen 
bliver klar inden for en given tidsperiode. 
\begin{lstlisting}[label=Timeout,
  caption=Timeout i Alternation (fra dokumentationen til PyCSP)]
  Alternation([{Timeout(seconds=0.5):None},
               {Cin:None}]).select()
\end{lstlisting} 

I denne alternation er processen villig til at læse fra Cin i 0.5 sekunder. 
Ellers accepteres timeoutguarden og processen er ikke længere villig til at 
læse fra Cin.

Med et simuleringsmiljø er det ikke nok udelukkende kan kunne specifiere en 
timeout på kanalen, det er også nødvændigt at man kan specificere at en proces 
er villig til at kommunikere på et specifikt tidspunkt, samt at den kanalen 
kun er villig til at kommunikere på nuværende tidpunkt, men ikke ud 
i fremtiden. 

At ville kommunikere fra et given tidspunkt i fremtiden,  svare til at vente 
uden at lave noget indtil det givne tidspunkt for så at forsøge at kommunikere 
fra tidpunktet indtil kommunktationen lykedes. Dette kan dermed laves helt 
uden en alternation, men ved blot med de to funktioner Wait(time), Cin(). 

At ville være villig til at kommuikere til et given tidspunkt, medfører en ny 
problemstilling, da det kan introducere muligheden for deadlocks og 
nondeterminisme, \fxnote{Er det korrekt?}, for det er ikke defineret hvad 
tiden er hvis det ikke lykkedes at kommunikere i det givne tidsskridt. Der 
findes to muligheder, enten skal scheduleren signalere at der ikke findes mere 
arbejde til dette tidsskridt, og lade processerne fortsætte i samme 
tidsskridt. Alternativt skal tiden tælles op til næste event, hvorefter 
processerne signaleres med at kommunkationen ikke lykkedes. 

\textbf{Timeout i samme tidsskridt}\\
Hvis man vælger at processerne skal signaleres i samme tidsskridt, vil en 
timeout efterligne en SKIP guard, men hvor en alternation med en SKIP guard 
med det samme kan fortsætte vil en timeout kræve at der blev ventet indtil der 
ikke var flere processer der kunne processeres i samme tidsskridt. Når der 
ikke er flere processer at vælge imellem skal de ventende processer fortsætte. 
Her er muligheden enten at signalere hver proces en af gangen, og lade den 
fortsætte inden næste proces signaleres, eller alternativt, samtidigt at 
signalerer alle de ventende processerne.

Ved at signalere samtlige processer indføres muligheden for en livelock. Dette
sker hvis to eller flere processer er  synkroniseret i den samme tidsrytme.
Et eksempel er hvis de alle i samme periode først ønsker at modtage data, for 
derefter at sende data. Her vil alle processerne uden timeouts vente på 
hinanden i en deadlock, men med en timeout vil de alle fortsætte samtidigt og 
indgå i en ny deadlock, PyCSP vil derfor med timeouts gå fra en deadlock til 
en livelock. En livelock er defineret som hvor tilstandenen i ændres men der
foregår ikke reelt arbejde\fxnote{skal vi introducere begrebet deadlock, 
livelock mv.}. 

Ved at aktivere en proces ad gangen har denne proces mulighed for i samme 
tidsskridt at indgå i kommunikation med en af de andre ventende processer. 
Deadlocken kan man dermed løse og man har mulighed for at undgå livelock 
problemet, ved samtidig signalering.
Ulemperne er at der skal foretages et valg om hvilke processer der signaleres 
med  timeout, og dermed har man risikoen for starvation\fxnote{ref?} hvis det 
er den/de samme processer der bliver signaleret.

\textbf{Timeout i et efterfølgende tidsskridt}\\
Ved at vælge at en timeout først forekommer i et efterfølgende tidsskridt, har 
alle processer haft den maksimale mulighed for at indgå i en kommunikation. 
Desuden kan alle processerne signaleres samtidigt, da et alle  timeouts er 
overskredet. Man skal dog vælge enten at fortolke en timeout i samme tidskridt  
som en timeout efter $\epsilon$, hvor $\epsilon$ sættes til et vilkårligt 
lille tidsinterval. Da tiden springer i vilkårligt små tidsskridt i  en 
simuleringen, vil en fast størrelse af $\epsilon$ risikere at påvirke 
rækkefølgen af events. Alternativt kan man vælge at lade tiden springe til 
nærste event, og der signalere alle timeouts. Begge muligheder har dog 
implicit det problem at timeout var sat til 0 og ikke til hverken et 
vilkårligt lille $\epsilon$ eller anden tidsenhed og man derfor ændrer på 
fortolkningen af kode.

\subsection{Vores valg} 

Timeouts i Timed PyCSP er en af de vigtigste funktioner, da det disse giver en
der ikke er data, mtimeout processen fortsætte  tildet under antagelsen af 
problemer.

når tiden er  tidspunkt
til for et findes der allerede \fxnote[inline]{vi skal kunne angive
at vi ønsker at kommunikere men KUN i det tidsskridt vi er i, og at
hvis dette ikke kan lade sig gøre skal vi breake noget alla at have en
timeout på 0} 
