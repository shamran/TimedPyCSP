\section{Repræcentation af tid}

I PyCSP foregår kommunikation kun når begge kanalender er klar dvs.
når der findes både en kanalende der vil skrive og en kanalende der vil læse. 
Hvis kun en af kanalenderne er klar, vil den vente indtil
der findes minumum en kanalende af hver type, der er klar. I alternation 
findes muligheden for at tilknytte en timeout til en guard. Dette
giver muligheden for at en process, kun er villig til at vente på at kanalen 
bliver klar inden for en given tidsperiode. 
\begin{lstlisting}[label=Timeout,
  caption=Timeout i Alternation (fra dokumentationen til PyCSP)]
  Alternation([{Timeout(seconds=0.5):None},
               {Cin:None}]).select()
\end{lstlisting} 

I denne alternation er processen villig til at læse fra Cin i 0.5 sekunder. 
Ellers accepteres timeoutguarden og processen er ikke længere villig til at 
læse fra Cin.

Med et simuleringsmiljø er det ikke nok udelukkende kan kunne specifiere en 
timeout på kanalen, det er også nødvændigt at man kan specificere at en proces 
er villig til at kommunikere fra et tidspunkt, samt at den kanalen kun er 
villig til at kommunikere på nuværende tidpunkt, men ikke ud i fremtiden. 

At ville kommunikere fra et given tidspunkt i fremtiden,  svare til at vente 
uden at lave noget indtil det givne tidspunkt for så at forsøge at kommunikere 
fra tidpunktet indtil det kommunktationen lykedes. Dette kan dermed laves helt 
uden en alternation, men ved blot med de to funktioner Wait(time), Cin(). 

At ville være villig til at kommuikere til et given tidspunkt, medfører en ny 
problemstilling, da det kan introducere muligheden for deadlocks og 
nondeterminisme, \fxnote{Er det korrekt?}, for det er ikke defineret hvad 
tiden er hvis det ikke lykkedes at kommunikere i det givne tidsskridt. Der 
findes to muligheder, enten skal scheduleren signalere at der ikke findes mere 
arbejde til dette tidsskridt, og lade processerne fortsætte i samme 
tidsskridt. Alternativt skal tiden tælles op til næste event, hvorefter 
processerne signaleres med at kommunkationen ikke lykkedes. 

Hvis processerne signaleres i samme tidsskridt kan man vælge enten at 
signalere hver proces en af gangen, og lade den fortsætte, eller samtidigt at 
signallerer til alle ventende processerne at de skal fortsætte.
Ved at signallere samtlige processer indføres muligheden for en livelock. 
Dette kan ske ved at have to eller flere processe synkroniseret  til samme 
tidsrytme. Hvis de  alle i samme periode prøver først at modtage data, for 
derefter at sende data. Her vil alle processerne vente på hinanden i en 
deadlock, men med en timeout vil de alle fortsætte samtidigt og indgå i en ny 
deadlock. Udefra vil det kunne konstatere at tiden går, men da der ikke 
foregår reelt arbejde indtræder der en livelock\fxnote{skal vi introducere 
begrebet deadlock, livelock mv.}. 

Ved at aktivere en proces af gangen har denne proces mulighed for i samme til 
den  samme tid at indgå i en kommunikation med en af de andre ventende 
processer, dermed har man muligheden for at løse livelock problemet med
processen fortsætte  tildet under antagelsen af problemer.




når tiden er  tidspunkt
til for et findes der allerede \fxnote[inline]{vi skal kunne angive
at vi ønsker at kommunikere men KUN i det tidsskridt vi er i, og at
hvis dette ikke kan lade sig gøre skal vi breake noget alla at have en
timeout på 0} 
