\subsection{Scheduler}
Med valget af greenletversionen som grundversionen, og med henblik på at hovedparten af vores ændringer vil være i scheduleren, vil vi kort gennemgå denne.

\begin{lstlisting}[firstnumber=132,stepnumber=5,numbers=left, float, label=fig:scheduling, caption=Uddrag af Scheduler.py i greenletsversionen.]
    def getInstance(cls, *args, **kargs):
        '''Static method to have a reference to **THE UNIQUE** instance'''
        if cls.__instance is None:
            # (Some exception may be thrown...)
            # Initialize **the unique** instance
            cls.__instance = object.__new__(cls)

            # Initialize members for scheduler
            cls.__instance.new = []
            cls.__instance.next = []
            cls.__instance.current = None
            cls.__instance.greenlet = greenlet.getcurrent()

            # Timer specific  value = (activation time, process)
            # On update we do a sort based on the activation time
            cls.__instance.timers = []

            # Io specific
            cls.__instance.cond = threading.Condition()
            cls.__instance.blocking = 0
\end{lstlisting}

 I \cref{fig:scheduling} ses et uddrag af initialiseringskoden. Dels findes der tre lister af processer som scheduleren har mulighed for at vælge imellem når der skiftes proces.  
 \begin{list}
 \tightlist 
 \item \code{new}: Initeres på linje 140, og består af processer som lige er blevet scheduleres for første gang.
 \item \code{next}: Initeres på linje 141, og indeholder de processer der er klar til at blive kørt, og som har været kørt før.  
 \item \code{timers}: Initeres på linje 147, og indeholder de processer der har tilknyttet en timeout. De skal først scheduleres på et senere tidspunkt og venter dermed blot. Hvert element i listen består både af processen samt et tidsstempel for hvornår processen skal genaktiveres. Denne liste bliver gensorteret hver gang der indsættes en ny proces.
 \item \code{blocking}: Initieres på linje 150, og er en variabel.Processer der venter på IO operationer, er ikke klar til at blive scheduleret, men heller ikke afsluttet. Scheduleren kan derfor ikke schedulere dem, men holdes styr på antallet af ventende processer vha. denne variabel, for at kunne afgører om Scheduleren skal afslutte eller afvente.
\end{list}

Når \sched en er startet, itererer den igennem alle tre lister, indtil de alle er tomme, og der ikke er nogle processer der er blokeret. Dette betyder at der ikke længere kan komme processer der ønskes at blive lagt på \sched en, og den kan dermed afslutte.

For at markere at vi ikke kun skal foretage en planlægning
af processerne, men foretage en simulering, har vi lavet en
\code{Simulation} klasse der arver fra \code{Scheduler}. Alle ændringer
vi skal foretage for at gå fra en almindelig \sched ~til en simulerings
\sched, vil således indkapsles i denne klasse, mens alt hvad de to
klasser har til fælles vil være isoleret i greenlets versionen af
\code{Scheduler} klassen. Dette har yderligere den fordel at man tydeligt kan se
at alle klasserne i simulation versionen arver en simulerings \sched ~og
ikke \code{Scheduler} fra greenletsversionen.

%\fxnote{dårlig overskrift}{\subsection{Repræsentation af tid}} Vi
%vil i dette afsnit gå i dybden med listen \code{timers} der findes i
%klassen \code{Scheduler}, samt se hvordan den kan inkorporeres i vores
%design.

\subsection{Tid i greenletsversionen} I \pycsp foregår kommunikation
kun når begge kanalender er klar dvs. når der både findes en
kanalende der vil skrive og en kanalende der vil læse. Hvis
kun en af kanalenderne er klar, vil den vente indtil der findes
minimum en kanalende af hver type, der er klar. Dette medfører
risikoen for at processen aldrig kommer videre, men går i deadlock.
I \pycsp har man derfor i \code{alternation} mulighed for at
tilknytte en timeout til en \code{guard}. Dette giver mulighed for
at en proces, kun er villig til at vente på kommunikation i en
given tidsperiode. 
\begin{lstlisting}[float=hbtp, label=Timeout,caption=Timeout i Alternation (fra dokumentationen til PyCSP)]
Alternation([{Timeout(seconds=0.5):None}, 
             {Cin:None}]).select()
\end{lstlisting}

I \cref{Timeout} ses et minimalt eksempel hvor processen kun er villig
til at læse fra kanalenden \code{Cin} i $0.5$ sekunder. Hvis ikke der
er modtaget en besked indenfor 0.5 sekundt, accepteres timeoutguarden
og processen er ikke længere villig til at læse fra \code{Cin}, og
fortsætter sin kørsel.

Tid er dermed blevet introduceret i \pycsp, men kun for at at have
mulighed for at tilknytte timeout til en \code{alternation}. Vi ønsker
at videreudvikle denne struktur til at håndtere tidsdelen for alle
processer, samt for at fungere med diskret tid, modsat den eksisterende
løsning hvor tiden er kontinuerligt.

\subsection{Timers}  
Vi forventer at brugen af
listen \code{timers}, vil øges betragteligt og at den gennemsnitlige
længde af listen vil stige, når der udvikles simuleringsproblemer. Dermed 
øges kravet om en effektiv implementation af \code{timers}\fxnote{skal 
vi evaluere om dette rent faktisk forbedrer ydelsen}. 

For at forbedre ydelsen af \code{timers} listen, 
ændrer vi den fra en almindelig liste, til en min"-hob. En hob har
flere fordele ved skemaplanlægning og er nævnt i introduktionen til Pythons implementation af en hob\fxnote{ref til http://docs.python.org/dev/3.0/library/heapq.html}. 

Da en implementation af en hob
allerede findes i Pythoni modulet \code{Heapq}, som er effektivt implementeret i C, vælger vi at bruge denne. Den eneste handling
der ikke er som standard er implementeret, er fjernelsen af et arbitrært element
fra hoben. Dette sker i den eksisterende løsning når en proces
aktivere et andet valg i \code{alternation} end timeout. I dette tilfælde skal
processen ikke vente på sin timeout, men elementet skal fjernes fra
\code{timers} listen. For at fjerne et element i en hob, må man som i
en normal liste lave en lineær søgning i hoben, og derefter genoprette
hob"-egenskaben i listen. Dette vil dog ikke tage længere tid end det
allerede tager da en fjernelse af en timeout i greenletversionen på nuværende
tidspunkt bruger en lineær søgning, til at finde elementet der skal
fjernes, og genoprettelsen af hobegenskaben også tager lineær tid \inline{ref til construction of heaps can be done in linear time using Tarjas algorithm.\\$http://en.wikipedia.org/wiki/Tarjan\%27s\_algorithm$}For at se en forskellen mellem greenletversion der bruger en liste og simulationsversionen der bruger en hob kan man sammenligne \cref{sched_timer} linje 205 med \cref{sim_timer} linje 126.


\subsection{Diskret tid} For at konverterer greenletversionen der knytter sig til reel tid, skal vi ændre de steder som bruger tid. Som vi har beskrevet tidligere er det eneste sted tid er introduceret i forbindelse med timeout og dermed i listen \code{timers}. Vi kan dermed nøjes med at ændre de steder i \sched en som indvolvere \code{timers}. Det første sted hvor timers indgår er i udvælgelsen af hvilken proces skal vælges(\cref{sched_timer}). Her sammenlignes på linje 204  første tidsværdi i timers, med det nuværende tidspunkt i time klassen. Hvis det nuværende tidspunkt er større end værdien i timers udvælges denne proces til at køre næste gang og fjernes fra timers listen.

Da tiden er diskret, og kræver et aktivt valg før den skifter kan vi tilføje en yderligere begændsning i forhold til greenletsversionen. For simuleringsversionen skal tiden være præcist det der er angivet i \code{timers}, før processen skal aktiveres, og ikke kun størrer end som angivet i greenletsversionen.  Simuleringsversionen af den del der foretager udvælgelser en proces fra  \code{timers} kan ses i \cref{sim_timer}. 

\begin{figure}[hbtp]
\begin{minipage}[c]{\linewidth}
\begin{lstlisting}[firstnumber=204, label=sched_timer, caption=Udvælgelse af proces fra listen timers (fra scheduling.py)]
if self.timers and self.timers[0][0] < time.time():
  _,self.current = self.timers.pop(0)
  self.current.greenlet.switch()
\end{lstlisting}
\end{minipage}
\begin{minipage}[c]{\linewidth}
\begin{lstlisting}[firstnumber=124, label=sim_timer, caption=Udvælgelse af proces fra listen timers (fra simulation.py)]
if self.timers and self.timers[0][0] <= Now():
  assert self.timers[0][0] == Now()
  _,self.current = heapq.heappop(self.timers)
  self.current.greenlet.switch()
\end{lstlisting}
\end{minipage}
\end{figure}



\subsection{Funktionerne Now og Wait} I Python kan man benytte modulet
\code{time}, hvis man ønsker at introducer begrebet tid. Med dette
modul kan man få af vide hvad klokken er. fra en brugers synsvinkel
repræsenteres tiden som kontinuerlig, og hver gang en bruger spørge
om klokken, fås et bestemt tidspunkt. Med computere findes tid som
kontinuerligt begreb ikke, men derimod er tiden internt repræsenteret
som diskrete tidsskridt. Størrelsen af disse tidsskridt varriere
af bla. hvilken computer programmet køres på og operativsystem.
Når vi ønsker at introducere \des skal det ikke ses som diskret
modsat kontinuerligt, men at de enkelte tidsskridt i \des er af
variable størrelse modsat i modulet \code {time} der har en konstant
størrelse. Da man i \code{time} modulet har en fast tidsskridt og
tid i det kontinuerlig tifælde også er inddelt i faste størrelse
som eks. sekunder, kan man med time modulet måle tidsintevaller der
korrespondere med den kontinuerlige tid. I \des findes der ikke en
sammenhæng mellem den kontinuerlige tid og dens egen repræsentation af
tid. For \des er tid derimod blot et tal der starter som 0, og stiger
i abitrærer tidskridt. Når tiden i \des på denne måde er afkoplet
en relation almindelig tid, kan man heller ikke snakke om at et tidsrum
har sekunder eller timer. I \pycsp kan man i timeout planlægge en
begivenhed til at ske om f.eks. 5. sekunder. I \des findes sekunder som
begreb ikke, men man kan angiver at når tiden er talt op med 5 skal
begivenheden ske. \inline{Skal dette splittes oop og halvdelen skal i
teori?}

Når et problem modeleres i \des, vil der altid være behov for at
tilføje en sammenhæng mellem tid i problemet og et tid i modellen. Da
der der ikke findes en fast sammenhæng, skal modellen derfor eksplicit
definere om 5 sekunder skal repræsenteres som, at tiden internt i
\pycsp tælles op med 5, 0.5 eller 0.05.

Vi har valgt at repræsentere tiden som en intern variabel i \sched.
Dette kan vi gøre da \sched ~er en singelton og der findes derfor kun
en variabel med tid. For processer der ønsker at kende tiden har vi
introduceret funktionen \code{Now()} der returnere hvad tiden er på et
given tidspunkt.


\inline{På det teoretiske plan snakker vi om at planlægge
begivenheder, mens vi i implantationen snakker om Wait og at ''stall''
en process }


I programmeringssproget \simpy lader man en proces vente ved at
foretage kaldet \code{yield}. Dette yield sørger for at processen ikke
fortsætter før et foruddefineret tidsrum er gået.

\begin{lstlisting}[firstnumber=11 , stepnumber=2, numbers=left,float=hbtp, label=yield, caption= Et yield i \simpy (Taget fra Bank05.py i eksemplet fra \simpy)] 
def visit(self,timeInBank): 
  print now(), self.name," Here I am" 
  yield hold,self,timeInBank print now(),
  self.name," I must leave" 
\end{lstlisting}

I \cref{yield} ses hvordan en kundeproces ankommer til banken,
printer tiden, foretager et yield, og når processen fortsætter
fra dette kald er tiden steget med værdien \code{timeInBank}.
Til slut printer processen igen tiden. Brugen af yield er knyttet
til implementeringen af \simpy og skyldes at \simpy implementere
hver process som en \code{corutine}. Vi skal i \pycsp have en
ligende mulighed for at lade en proces vente. Da dette allerede er
implementeret via timeout i greenlets versionen af \pycsp, kan vi
uden at ændre i den eksisterende \sched tilføje en ny funktion
\code{Wait} der fungere som timeout, men kan kaldes af processerne
på et vilkårligt tidspunkt. \fxerror{Dette skal måske ændres
da jeg ikke har talt med run om nødvændigheden af while now. Og jeg har derfor ikke beskrevet i teksten hvordan funktionen virker.}

\begin{lstlisting}[firstnumber=20,float=hbtp, label=wait, caption=Wait i simuleringsversionen.] 
def Wait(seconds): 
  logging.debug("calling wait")
  Simulation().timer_wait(Simulation().current, seconds) 
  t = Now()+seconds
  while Now()<t: 
    p = Simulation().getNext() 
    logging.debug("Wait swicthing from %s to %s"%(Simulation().current, p)) p.greenlet.switch()
\end{lstlisting}

Funktionen \code{Wait} er essentielt det eneste værktøj der skal til for at planlægge en begivenheder ud i fremtiden, og vi har på nuværenede tidspunkt en  simpel begivenhedssimulator der kører i reel tid.


