\chapter{\des}
  \section{Beskrivelse/teori}\label{sec:des-theory}
    \inline{Beskrivelse af tidsmodellen, teorien omkring den og hvor/hvad den 
    benyttes til. Teori: henvisning til litteratur, bl.a.  matematik/beviser 
    for modellen}
   
\subsection{Barrierer}\label{barrier}
I \des findes der i modsætningen til Parallel \des \fixme{referencer} en global 
tid og alle processerne skal derfor have en fælles tid der tæller op samtidigt.  
En global viden som tid kræver synkronisering af alle processerne\fxnote{ref}, 
og til denne koordinering og synkronisering af flere processer er den mest 
brugte metode at introducere en barriere.

Barrierer blev først introduceret i MPI\fxnote{ref}, hvor den bruges til at 
sikre at alle tråde venter i barrieren før de kan fortsætte. 

I \pycsp kan man udnytte at begge kanalender skal være klar, før der kan 
kommunikeres og at en process der er indgår i en kommunikation vil vente indtil 
den anden ende er klar før den fortsætter. Ved hjælp af kanaler kan man derfor 
lave en simpel barriere trivielt ved brug af kommunkation over kanaler. En 
implementation af en barriere som en selvstændig process kan eksempelvis 
implementeres som i \cref{barrier-imp}.

\begin{lstlisting}[float, label=barrier-imp,caption=En barriere i \pycsp]
@process
def Barrier(nprocesses, signalIN, signalOUT):
	while True:
		for i in range (nprocesses):
			signalIN()
		for i in range (nprocesses):
			signalOUT(0)
\end{lstlisting}

Denne implementation af en barriere kræver, i modsætning til MPI versionen af 
en barriere, to kald. Det første sender en variabel til barriereprocessen, mens 
det andet kald modtager en dummyværdi fra barriereprocessen. Det kræver derved 
to kanaler at implementere barrieren. På den ene kanal er barrieren den eneste 
der læser værdierne; en besked sendt på denne kanal vil derfor altid modtages 
af barrieren. På den anden kanal er barrieren den eneste der skriver, og en 
modtaget besked må derfor komme fra barrieren.

Vi kan overbevise os om korrektheden af barrieren, da alle processerne først 
går ind i barrieren ved at sende en værdi til barrieren. Hvis barrieren ikke er 
klar, sikrer CSP at processerne venter indtil barrieren er klar til at modtage 
værdierne. Først når barrieren har modtaget en værdi fra alle processerne, 
begynder barrieren at sende sin værdi, og det er først når en proces modtager 
denne værdi fra barrieren at den må fortsætte. Når en proces modtager værdien 
fra barrieren fortsætter den og man kan risikere at den ønsker at gå ind i 
barrieren inden denne har sendt sin værdi til alle processer. den første proces 
vil gå i stå ved forsendelsen af sin værdi til barrieren\inline{skriv mere 
eksplicit at det her forhindrer processer i at komme foran}, da barrieren først 
kan modtage værdier fra processer når den har sendt sin værdi til alle 
processer.

En ulempe ved denne simple barriere er at antallet af processer skal være 
konstant gennem hele kørslen.
Dette er f.eks. et problem i bankeksemplet (\cref{bank-eksempel}), hvor 
generatorfunktionen kan slutte lige efter at have genereret den sidste kunde.  
Her må den fortsætte med blot at kalde barrieren, indtil servicedisken har 
processeret alle kunderne, før hele programmet kan afslutte. Alternativt må 
barriereprocessen ændres, så den dynamisk kan ændre på hvor mange processer der 
skal synkroniseres. \inline{skal vi fortælle hvordan der kan gøres i \pycsp}

\fxnote[inline]{fortsættes med ulemper med barriere og generelt hvorfor vi 
skal holdes os fra det. noget med at man skal kalde barrieren to  gange}

\section{Eksempel}
\fxnote[inline]{Beskrivelse af eksemplet og hvordan det er relateret til problemet/modellen. Beskrivelse af løsning uden vores tid}


\subsection{Hajer og fisk på Wator} Som et eksempel på en \des har vi valgt at 
tage  udgangspunkt i det scenarie som A. K. Dewdney
beskrev i artiklen \citetitle{wator}\cite{wator}. Artiklen beskriver den
fiktive planet Wator, der har form som en torus og er fuldstændig
dækket af vand. Verdenen er inddelt i felter \cite[20]{wator}, som kan være tomme, indeholde en
fisk eller en haj. Følgende karakteristika beskriver fisk og hajers
opførsel.

\begin{itemize}
\item[\textbf{Fisk}]
Lever af plankton, en ressource som er uendelig. Hvis der er èt ledigt 
tilstødende felt, bevæger den sig til dette felt. Hvis der er flere ledige 
felter vælges et tilfældigt. Såfremt en fisk overlever 3 tidsskridt forplanter 
den sig.
\item[\textbf{Hajer}]
Såfremt der er fisk i et eller flere tilstødende felter, vil hajen bevæge sig 
til et af disse felter og spise fisken. Hvis der er ikke er nogen fisk i et af 
disse felter flytter hajen sig til et tilfældigt valgt ledigt felt. Hvis en haj 
ikke spiser i 3 tidsskridt dør den. Overlever den i 10 tidsskridt forplanter 
den sig.
\end{itemize}

For hvert tidsskridt vil alle fisk og hajer udføre en handling ud fra
ovenstående opførsel.
Til at initiere systemet skal der defineres en størrelse af verdenen,
samt hvor mange fisk og hajer der er til stede fra start. Disse fisk og
hajer placeres tilfældigt i verdenen.
Såfremt de initielle parametre for antal fisk og hajer understøtter en 
bæredygtig bestand forventer vi at se bestanden af henholdsvis fisk og hajer 
oscillerer afhængigt af hinanden.

Vi har valgt dette eksempel, da det er enkelt og let forståeligt, men samtidig 
introducerer problemstillinger omkring synkronisering når det paralleliseres.  
Disse problemstillinger optræder fordi en opdatering af hvert felt er afhængigt 
af de omkringliggende felter, og vil derfor være afhængig af felter fra andre 
processer i grænsetilfælde. Ud over at være afhængig af information fra andre 
processer, kan en opdatering også påvirke data hos andre processer.   
\fxnote[inline]{Noget om real world applikation? - s: jeg synes det er fint sådan her}

\subsubsection*{Før introduktion af et tidsbegreb i CSP} For at simulere Wator 
verdenen i et CSP-system hvori tidsbegrebet ikke er introduceret, er vi nødt 
til at udføre en synkronisering af de enkelte processers arbejde. Denne 
synkronisering kan ske ved brug af barrierer, hvor alle processer udfører en 
handling og mødes i barrieren før de fortsætter.

Vi har valgt at basere vores model på \citetitle{crew}\cite{crew}\fxnote{Brian: 
Hvad er din holdning til litteraturhenvisninger.}, hvor verdenen repræsenteres 
som en delt datastruktur og adgangen til denne styres med barrierer. I vores 
model er hver proces derved ansvarlig for en del af verdenen og tilgangen til 
den delte datastruktur sker ud fra CREW-princippet (Concurrent Read, Exclusive 
Write)\cite[5]{crew}, der styres vha. barrierer. 

Vi deler verdenen lodret, hvor hver proces styrer en verdensdel. Hver proces 
gennemgår sin verdensdel og udfører en mulig handling for hver fisk og haj, dog 
vil fisk og hajer i de sidste to kolonner i hver verdensdel ikke bliver 
opdateret på nuværende tidspunkt. Dette skyldes at i disse to kolonner vil en opdatering\inline{bedre ord} af fisk og hajer kunne risikere en race condition\fxnote{ref}, fra hhv. processen selv og processen til højre.
 Når denne opdatering er fuldført mødes processerne i en barriere, 
hvorefter hver proces opdaterer de to sidste kolonner. Herefter mødes 
processerne igen i barrieren, og når alle kolonner er opdateret, kan der 
foretages en visualisering af de udførte opdateringer. Til slut mødes alle i en 
barriere igen før processerne kan begynde en ny iteration.
\fxnote[inline]{pseudo kode eksempel?}

En repræsentation af opdelingen ses på \cref{fig:wator}. Her er verdenen 
opdelt mellem to processer, og de to kolonner mellem hver del opdateres i et 
separat tidsskridt. Når disse to tidsskridt er udført kan der foretages en 
visualisering, hvorefter næste iteration af opdateringer kan begyndes. \inline{gentagelse}
\begin{figure}[hbtp] \begin{center}
  \includegraphics[scale=0.75]{images/wator}
  \caption{Opdeling af verdenen mellem to processer. Der er for hver verdensdel 
  to kolonner som opdateres i et separat tidsskridt.}
  \label{fig:wator}
  \end{center}
\end{figure}

I en mere ren CSP-model ville man foretage en direkte udveksling af data mellem 
processerne, og undgå den delte datastruktur vi har i vores model.  Vi har 
valgt denne model frem for den mere rene CSP model, da den klarlægger brugen af 
barrierer bedre.  Det bliver meget eksplicit i koden hvornår hvilke dele 
opdateres, og hvornår processerne venter i en barriere.\inline{flyttes langt op.. til valg af CREW model}

\begin{figure}[hbtp]
\begin{minipage}{\linewidth}
\begin{lstlisting}[label=wator-worldpart,caption=Uddrag af processen 
  \emph{worldpart} i Wator]
  @process
  def worldpart (part_id, barR, barW):
  
  ...
  
  while True:
      #Calc your world part:
      main_iteration()
      barW(1)
      barR()
      #Update the two shadowcolumns
      for i in range(world_height):
        for j in range(2):
          element_iteration(Point(right_shadow_col+j,i))
      barW(1)
      barR()
      #visualize have single access
      barW(1)
      barR()
\end{lstlisting}

\begin{lstlisting}[label=wator-visualize,caption=Processen \emph{visualize} i 
  Wator]
@process
 def visualize(barR,barW):
   for i in xrange(iterations):
     barW(1)
     barR()
     barW(1)
     barR()
     pygame.display.flip()
     barW(1)
     barR()
   poison(barW,barR)
\end{lstlisting}

\texttt{\emph{barW(1)} og \emph{barR()} er henholdsvis skrivning og læsning til og 
fra en barriere som defineret i \cref{barrier}}. 
\vspace{1cm}
\end{minipage}
\end{figure}
Afviklingen af programmet sker ved at et antal \emph{worldpart}-, en 
\emph{visualize}- og en \emph{barrier}-process køres parallelt. Af 
 \autoref{wator-worldpart} og \vref{wator-visualize}, ses det overordnede design af hhv. \emph{worldpart}- og \emph{vizualize}processen.  Værd at bemærke er det store antal barrierkald til visualizeprocessen. Dette er til for at man kan benytte den samme barrier som wordpartprocessen. Alternativt kunne man have to barriererprocesser; en til synkronisering af \emph{worldpart} med \emph{vizualize}, samt en som \emph{worldpart}processerne brugte til synkroniseringen af opdatering af verdensdelen og de to sidste kolonner. 

\fxnote{konklusion hvordan var det at implementerer og hvor stor parallelitet kan man opnå. }


\subsection{Kunder i en bank}\label{bank-eksempel}
Et klassisk eksempel inden for \des er at simulere  en række kunder der alle 
ankommer til en butik, hvor de skal serviceres. Dette simple problem kan 
udvides til at modellere mange forskellige problemstillinger, der berører 
hvordan flowet ændrer sig hvis man varier en eller flere parametre
i systemet. Programmeringssproget \simpy\fxnote{ref}har, som et af deres 
eksempler, en simulering af kunder i en bank. \simpy bruger dette som et 
gennemgående eksempel, hvor de løbende udvider modellen, for at vise 
forskellige egenskaber ved \simpy. For at kunne sammenligne \simpy  med vores 
implementation af logisk tid, vil vi implementere to af eksemplerne med kunder 
i en bank i \pycsp.

I det simple tilfælde af eksemplet ankommer der en kunderne til banken på på 
tilfældige tidspunkter\inline{ental eller flertal her? ``en kunderne'', 
``tilfældige tidspunkter''}.  Hun opholder sig i banken i et andet tilfældigt 
tidsrum, hvorefter hun igen forlader banken. I dette eksempel kan der ikke 
uddrages meget information, men det viser hvordan en simpel model er opbygget i 
hhv.  \simpy og \pycsp for at håndtere tid.

I det andet eksempel er modellen udvidet med en servicedisk. Her skal alle 
kunderne betjenes af en servicemedarbejder, som kun kan ekspederes en kunde ad 
gangen. Alle kunder ankommer igen til banken i tilfældig orden og stiller sig i 
kø for at blive serviceret. Dette  svare til en M/M/1\fixme{hvad  er en m/m/1 
kø} kø. Det er igen et tilfældigt tidsrum som kunden bruger på at blive 
serviceret.  Dette er stadigt en meget simpel model, men med introduktionen af 
en begrænset ressource kan man uddrage information om den tilhørende kø, f.eks. 
kan der måles hvor lang det tager for hver kunde at blive betjent af 
servicemedarbejdere, samt hvordan køen opfører sig over tid. 

\subsubsection{Før introduktion af et tidsbegreb i \pycsp}
I \simpy er kunderne en proces og det vil derfor være nærliggende ligeledes at 
modellere eksemplet i \pycsp med kunder som en proces. Dette sker i  \simpy når
generatorfunktionen laver en kunde og lader denne køre parallelt med sig selv.  
I \pycsp,\fxnote{hvorfor?- kan man lave child proces der køre i samme parallel 
kald som dets parent?} er standard metoden\fxnote{set fra kodeeksempler}, at 
modellere mere statiske processer, gerne med en source- og 
sinkproces\inline{bedre ord end source og sink}, og lade arbejdet flyttes 
mellem processerne igennem kanaler. I \pycsp modellen fungerer 
generatorprocessen stadigt som en source, men vi introducerer en bankproces som 
sink, og lader kunderne være arbejdet der flyttes mellem dem. 

Mens \simpy kalder kundeprocessen og lader denne stå for håndteringen af kunden 
og tiden hun befinder sig i banken, kender bankprocessen i \pycsp ikke tid som 
sådan, og skal derfor selv holde en liste med kunderne i banken og til hver 
tidskridt vide hvilke kunder der skal forlade banken. 

Tiden er igen modelleret ved brug af barrierer, se afsnit \cref{barrier}, men i 
stedet for at kalde barrierens to krævede kald, lige efter hinanden, som 
barrieren er designet til, for at være sikker på vi er i samme tidsskridt lader 
vi bankprocessen gå ind i barrieren i starten af tidsskridtet, og så modtage 
kunder, indtil banken modtager et kald om at forsætte til næste tidsskridt af 
barrieren (se \cref{bank-alternation-imp})\inline{lang uklar sætning, 
omformuler}. Dette er smart og nødvendigt for at lade banken have mulighed for 
at modtage et vilkårligt antal kunder i samme tidsskridt, samt vide hvornår der 
ikke vil komme flere kunder.  Vi kan ræsonnere os til at barrieren stadig 
virker efter hensigten ved at indse, at for at\inline{omformuleres} generatoren 
kan komme foran med et tidsskridt og sende en kunde i et forkert tidsskridt 
skal den have fuldført begge begge kald til barrieren, men barrieren vil ikke 
modtage et kald fra nogle før det har kaldt bankprocessen, og derfor må 
generatoren vente i sit første kald til barrieren, indtil banken har modtaget 
sit kald fra barrieren, og når bankprocessen har modtaget et kald fra barrieren 
er denne ikke længere villig til at modtage kunder før i det efterfølgende 
tidsskridt\inline{lang uklar sætning}. Vi kan bruge samme analogi til at 
ræsonnere os frem til at bankprocessen ikke kan komme et tidsskridt foran 
generatorfunktionen, og derfor virker barrieren stadigt som forventet. 

\begin{lstlisting}[float=hbtp,label=bank-alternation-imp,caption=Modtage en kunde eller 
	barrier i Bankprocessen]
while True:
		(g,msg) = Alternation([{
		barrierREADER:None,
    customerREADER:None
    }]).select()
		if g == barrierREADER:
			break
    elif g == customerREADER:
			heappush(customers,(time+msg.waittime,msg))
\end{lstlisting}

Da dette eksempel er taget fra \simpy, egner det sig selvfølgelig godt til 
simulering, og fra eksemplet kan man også se at der findes meget kode til 
vedligeholdes af de interne tidsvariabler, som \simpy ikke har. Det drejer sig 
om kode der sørger for at hver proces kender tiden, samt at den er 
synkroniseret på tværs af processerne. Vi forventer derfor at koden skal kunne 
simplificeres i \pycsp med tid, så det bliver lige så simpelt som i 
\simpy.\inline{Relevans for konteksten? det hænger hverken sammen med 
foregående eller følgende afsnit}

I det mere avancerede eksempel hvor kunderne skal tilgå den samme begrænsede 
ressource dannes en kø. Denne kan i \pycsp modeleres på flere måder, afhængigt 
at hvilken proces der skal have ansvaret for at vedligeholde køen. En metode er 
internt i en proces at have en liste\inline{liste over hvad?}, og lade det være 
processens ansvar at håndtere denne liste som en kø. Processen med ansvaret kan 
så enten være den begrænsede ressource, eller en separat proces hvis eneste 
formål er at vedligeholde køen. For nyligt\footnote{d. 22. december 2009} er 
der i \pycsp blevet introduceret ''buffered channels''\cite{pycsp-r147}, og 
disse kan også bruges som en kø. Dermed kan man modellere sin ressource og lade 
den læse fra kanalen når den er klar uden at skulle beskæftige sig med køen, og 
uden at skulle implementere en hjælperproces til håndtering af køen. Vi har i 
dette eksempel valgt at lade køen være repræsenteret ved en ''buffered 
channel'', da denne  kræver færrest linjer kode, men den kunne lige så godt 
være repræsenteret som en liste i servicedisk processen.

I \simpy findes begrebet ressource direkte i sproget, som en type og 
servicedisken er blot en instans af denne type, og ressourcen står selv for at 
håndtere køen. I \pycsp modelleres servicedisken som en separat proces, og 
bankprocessen er defor reduceret til blot at sende kunden videre til 
servicedisken og lade kanalen håndtere køen. En ulempe ved brugen af ''buffered 
channels'' som en kø er, at kanalen har en fast størrelse på sin buffer, som 
angives når kanalen oprettes.  Man kan dermed risikere ved brug af ''buffered 
channels'' sammen med barrierer en deadlock hvis ikke processen i samme 
tidsskridt kan foretage transmissionen og kalde barrieren. \inline{Uklar 
formulering of mærkelig ordstilling}
Dette kan løses med en alternation og skip guard\inline{find en standard som vi 
bruger til at referere til kode-elementer med, fx emph, tt eller andet}, men så 
skal banken håndtere fejlede forsendelser og må nødvendigvis introducere en 
sekundær kø hvilket gør at introduktionen af en ''buffered channel'' er 
irrelevant. Til at løse dette problem har vi i vores tilfælde valgt blot at 
angive en maksimal størrelse på bufferen som er større end det totale antal 
kunder banken modtager.

  \section{Design og implementation}
    \fxnote[inline]{Beskrivelse af design med udgangspunkt i eksemplet}
    %\input{chapters/time-implementation}
  \section{Evaluering}
    \fxnote[inline]{Evaluering af hvordan eksemplet løses efter den valgte 
    implementation benyttes. Inkluderer test+performance}
  \section{Fremtidigt arbejde}
  \section{Opsummering}
