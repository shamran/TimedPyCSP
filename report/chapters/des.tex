\chapter{\des}
  \section{Beskrivelse/teori}
    \fxnote[inline]{Beskrivelse af tidsmodellen, teorien omkring den og 
    hvor/hvad den benyttes til. Teori: henvisning til litteratur, bl.a.  
    matematik/beviser for modellen}
    
\subsection*{Barrierer}\label{barrier}
For at modellere eksemplet med kunder i en bank i PyCSP, skal der foretages en 
række valg. Først og fremmest skal det besluttes hvad der skal være processer, 
og hvordan  kanalerne skal forbindes. I \des findes der i modsætningen til 
PDES \fixme{referencer} en global tid og alle processerne skal derfor have  en 
fælles tid der tæller op samtidigt. Den mest brugte metode i CSP sammenhæng er 
at bruge en barrier \vref{barrier-imp}.

\begin{lstlisting}[label=barrier-imp,caption=En barrier i PyCSP]
@process
def Barrier(nprocesses, signalIN, signalOUT):
	while True:
		for i in range (nprocesses):
			signalIN()
		for i in range (nprocesses):
			signalOUT(0)
\end{lstlisting}

Barrier blev introduceret i MPI, og sikrer at alle tråde har nået dette punkt 
før de må fortsætte. I PyCSP er det trivielt at have  denne egenskab, da 
processer til begge kanalender er klar, og med to kanaler kan man sikre at 
ingen proces modtager et signal før alle processer har sendt et signal til 
barrieren.
\fxnote[inline]{fortsættes med ulemper med barriere og generelt hvorfor vi 
skal holdes os fra det. noget med at man skal kalde barrieren to  gange}

\section{Eksempel}
\fxnote[inline]{Beskrivelse af eksemplet og hvordan det er relateret til problemet/modellen. Beskrivelse af løsning uden vores tid}


\subsection{Hajer og fisk på Wator} Som eksempel på en \des har vi valgt at tage 
udgangspunkt i det scenarie som A. K. Dewdney
beskrev i artiklen \cite{wator}. Artiklen beskriver den
fiktive planet Wator, der har form som en torus og er fuldstændig
dækket af vand. Verdenen er inddelt i felter som beskrevet på side
20 i \cite{wator}. Disse felter kan være tomme, indeholde en
fisk eller en haj. Følgende karakteristika beskriver fisk og hajers
opførsel.


\begin{itemize}
\item[Fisk]
Lever af plankton, en ressource som er uendelig. Hvis der er en ledigt 
tilstødende felt, bevæger en fisk sig til dette felt. Hvis der er flere ledige 
felter vælges et tilfældigt. Såfremt en fisk overlever 3 tidsskridt forplanter 
den sig.
\item[Hajer]
Såfremt der er fisk i et eller flere tilstødende felter, vil hajen bevæge sig 
til et af disse felter og spise fisken. Hvis der er ikke er nogen fisk i et af 
disse felter flytter hajen sig til et tilfældigt valgt ledigt felt. Hvis en haj 
ikke spiser i 3 tidsskridt dør den. Overlever den i 10 tidsskridt forplanter 
den sig.
\end{itemize}


For hvert tidsskridt vil alle fisk og hajer udføre en handling ud fra
ovenstående opførsel.

Til at initiere systemet skal der defineres en størrelse af verdenen,
samt hvor mange fisk og hajer der er til stede fra start. Disse fisk og
hajer placeres tilfældigt i verdenen.

Såfremt de initielle parametre understøtter en bæredygtig bestand
forventer vi at se bestanden af henholdsvis fisk og hajer oscillerer
afhængigt af hinanden.


\textbf{Uden tid}
\fixme[inline]{bedre overskrift}
For at simulere Wator verdenen i et CSP-system hvori tidsbegrebet ikke er 
introduceret, er vi nødt til at udføre en synkronisering af de enkelte 
processers arbejde. Denne synkronisering kan ske ved brug af barrierer, hvor 
alle processer udfører en handling og mødes i barrieren før de fortsætter.
Vi har valgt at basere vores model på \cite{crew}, hvor verdenen repræsenteres 
som en delt datastruktur og adgangen til denne styres med barrierer. I vores 
model er hver proces derved ansvarlig for en del af verdenen og tilgangen til 
den delte datastruktur sker ud fra CREW-princippet (Concurrent Read, Exclusive 
Write) som angivet i artiklen, og styres vha. af barrierer. 

Vi deler verdenen lodret, hvor hver proces styrer en verdensdel. Hver proces 
gennemgår sin verdensdel og udfører en mulig handling for hver fisk og haj, dog 
vil fisk og hajer i de sidste to kolonner i hver verdensdel ikke bliver 
opdateret på nuværende tidspunkt. Dette skyldes at henholdsvis processen selv 
og den umiddelbar titl højre for den, har skriverettigheder til disse to 
kolonner.
Når denne opdatering er fuldført mødes processerne i en barriere, hvorefter 
hver proces opdaterer de to sidste kolonner. Herefter mødes processerne igen i 
barrieren, og når alle kolonner er opdateret, kan der foretages en 
visualisering af de udførte opdateringer. Disse skridt udføres et forudbestemt 
antal iterationer. 



\subsection{Kunder i en bank} Et klassisk eksempel inden for \des er at simulere  
en række kunder der alle ankommer til en butik, hvor de skal serviceres. Dette 
simple problem kan bruges til at modellere mange forskellige 
problemstillinger, som hvordan flowet ændrer sig hvis man varier en parameter 
i systemet. Programmeringssproget SimPy har som et af deres eksempel, en 
simulering af kunder i en bank. SimPy bruger dette som en gennemgående 
eksempler hvor de løbende udvider deres model for at vise forskellige 
egenskaber ved deres model. For at nemt at kunne sammenligne SimPy  med vores 
model vil vi bruge dette eksempel.

I det simple tilfælde af eksemplet ankommer der en kunde til banken på på et 
tilfældigt tidspunkt. Hun opholder sig i banken i et tidsrum, hvorefter hun 
igen forlader banken.

I det simple eksempel kan der ikke uddrages meget information, da banken ikke 
består af en begrænset ressource som kunderne skal tilgå.  Eksemplet er derfor 
også udvidet med en service disk, hvor alle kunderne skal betjenes af en 
servicemedarbejder. Alle kunder ankommer til banken i tilfældig orden og 
stiller sig i kø til at blive serviceret. Dette  svare til en M/M/1\fixme{hvad  
er en m/m/1 kø} kø.
\textbf{Uden tid}\fxnote{bedre overskrift}
I SimPy er kunderne en process og det vil derfor være nærliggende ligeledes at 
modelere eksemplet i PyCSP med kunder som en proces. i Simpy kalder 
generatorfunktionen kunderne og kan kører den parallelt med sig selv. 
I PyCSP\fxnote{hvorfor?- kan man lave child processes der køre i samme 
parallel kald som dets parent?}, er standard metoden\fxnote{set fra 
kodeeksempler} at modelere mere statiske objekter, med en source og sink 
process og lade arbejdet flyttes mellem processerne. Derfor er modellen ændret 
så  generatorprocesen stadigt fungere som en source, men vi introducerer en 
bankproces som sink, og lader kunderne være arbejdet der flyttes mellem dem. 

Mens SimPy  kalder kundeprocessen og lader denne stå for håndteringen af 
kunden og tiden hun befinder sig i banken, har bankprocessen i PyCSP ikke 
mulighed for at kende tid og skal derfor selv holde en liste med kunderne 
i banken og  til hver tidskridt vide hvilke af kunderne der skal forlade 
banken. 

Tiden er igen modelleret ved brug af barrier se \autoref{barrier}, men 
i stedet for  at kalde barrierens to krævede kald, lige efter hinanden, som 
normalt for at være sikker på vi er i samme tidsskridt lader vi bank
processen gå ind i barrieren i starten af tidsskridtet, og så modtage kunderi, 
indtil banken modtager et kald om at forsætte til næste tidsskridt af 
barrieren.
\begin{lstlisting}[label=bank-alternation-imp,caption=modtag kunder eller 
	barrier i Bankproces]
while True:
		(g,msg) = Alternation([{
		barrierREADER:None,
    customerREADER:None
    }]).select()
		if g == barrierREADER:
			break
    elif g == customerREADER:
			heappush(customers,(time+msg.waittime,msg))
\end{lstlisting}
Dette er smart, og nødvændigt for at lade banken have mulighed for at modtage 
et vilkårligt antal kunder i samme tidsskridt, samt vide hvornår der ikke vil  
komme flere kunder. Vi kan resonere os til at barrieren stadigt virker efter 
hensigten da for at generatoren kan komme foran med et tidsskridt og sende en 
kunde i et forkert tidsskridt skal have kaldt begge kald til barrieren, men 
barriernen vil ikke modtage et kald fra nogle før det har kaldt bankprocessen, 
og derfor må generatoren vente i første kald til barrieren indtil banken har 
modtaget sit kald fra barrieren. 

  \section{Design og implementation}
    \fxnote[inline]{Beskrivelse af design med udgangspunkt i eksemplet}
    \input{chapters/time-implementation}
  \section{Evaluering}
    \fxnote[inline]{Evaluering af hvordan eksemplet løses efter den valgte 
    implementation benyttes. Inkluderer test+performance}
  \section{Fremtidigt arbejde}
  \section{Opsummering}
