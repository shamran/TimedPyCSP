\chapter{Eksempler}

\section{Hajer og fisk på Wator} Som eksempel på en \des har vi valgt at tage 
udgangspunkt i det scenarie som A. K. Dewdney
beskrev i artiklen \cite{wator}. Artiklen beskriver den
fiktive planet Wator, der har form som en torus og er fuldstændig
dækket af vand. Verdenen er inddelt i felter som beskrevet på side
20 i \cite{wator}. Disse felter kan være tomme, indeholde en
fisk eller en haj. Følgende karakteristika beskriver fisk og hajers
opførsel.


\begin{itemize}
\item[Fisk]
Lever af plankton, en ressource som er uendelig. Hvis der er en ledigt 
tilstødende felt, bevæger en fisk sig til dette felt. Hvis der er flere ledige 
felter vælges et tilfældigt. Såfremt en fisk overlever 3 tidsskridt forplanter 
den sig.
\item[Hajer]
Såfremt der er fisk i et eller flere tilstødende felter, vil hajen bevæge sig 
til et af disse felter og spise fisken. Hvis der er ikke er nogen fisk i et af 
disse felter flytter hajen sig til et tilfældigt valgt ledigt felt. Hvis en haj 
ikke spiser i 3 tidsskridt dør den. Overlever den i 10 tidsskridt forplanter 
den sig.
\end{itemize}


For hvert tidsskridt vil alle fisk og hajer udføre en handling ud fra
ovenstående opførsel.

Til at initiere systemet skal der defineres en størrelse af verdenen,
samt hvor mange fisk og hajer der er til stede fra start. Disse fisk og
hajer placeres tilfældigt i verdenen.

Såfremt de initielle parametre understøtter en bæredygtig bestand
forventer vi at se bestanden af henholdsvis fisk og hajer oscillerer
afhængigt af hinanden.


\subsection{Uden tid}
\fixme[inline]{bedre overskrift}
For at simulere Wator verdenen i et CSP-system hvori tidsbegrebet ikke er 
introduceret, er vi nødt til at udføre en synkronisering af de enkelte 
processers arbejde. Denne synkronisering kan ske ved brug af barrierer, hvor 
alle processer udfører en handling og mødes i barrieren før de fortsætter.
Vi har valgt at basere vores model på \cite{crew}, hvor verdenen repræsenteres 
som en delt datastruktur og adgangen til denne styres med barrierer. I vores 
model er hver proces derved ansvarlig for en del af verdenen og tilgangen til 
den delte datastruktur sker ud fra CREW-princippet (Concurrent Read, Exclusive 
Write) som angivet i artiklen, og styres vha. af barrierer. 

Vi deler verdenen lodret, hvor hver proces styrer en verdensdel. Hver proces 
gennemgår sin verdensdel og udfører en mulig handling for hver fisk og haj, dog 
vil fisk og hajer i de sidste to kolonner i hver verdensdel ikke bliver 
opdateret på nuværende tidspunkt. Dette skyldes at henholdsvis processen selv 
og den umiddelbar titl højre for den, har skriverettigheder til disse to 
kolonner.
Når denne opdatering er fuldført mødes processerne i en barriere, hvorefter 
hver proces opdaterer de to sidste kolonner. Herefter mødes processerne igen i 
barrieren, og når alle kolonner er opdateret, kan der foretages en 
visualisering af de udførte opdateringer. Disse skridt udføres et forudbestemt 
antal iterationer. 



\section{Kunder i en bank} Et klassisk eksempel inden for \des er at simulere  
en række kunder der alle ankommer til en butik, hvor de skal serviceres. Dette 
simple problem kan bruges til at modellere mange forskellige 
problemstillinger, som hvordan flowet ændrer sig hvis man varier en parameter 
i systemet. Programmeringssproget SimPy har som et af deres eksempel, en 
simulering af kunder i en bank. SimPy bruger dette som en gennemgående 
eksempler hvor de løbende udvider deres model for at vise forskellige 
egenskaber ved deres model. For at nemt at kunne sammenligne SimPy  med vores 
model vil vi bruge dette eksempel.

I det simple tilfælde af eksemplet ankommer der en kunde til banken på på et 
tilfældigt tidspunkt. Hun opholder sig i banken i et tidsrum, hvorefter hun 
igen forlader banken.

I det simple eksempel kan der ikke uddrages meget information, da banken ikke 
består af en begrænset ressource som kunderne skal tilgå.  Eksemplet er derfor 
også udvidet med en service disk, hvor alle kunderne skal betjenes af en 
servicemedarbejder. Alle kunder ankommer til banken i tilfældig orden og 
stiller sig i kø til at blive serviceret. Dette  svare til en M/M/1\fixme{hvad  
er en m/m/1 kø} kø.


\section{Eksisterende PYCSP}
For at modellere eksemplet med kunder i en bank i PyCSP, skal der foretages en række valg. Først og fremmest skal det besluttes hvad der skal være processer, og hvordan  kanalerne skal forbindes. 
I DES findes der i modsætningen til PDES \fixme{referencer} en global tid og alle processerne skal derfor have  en fælles tid der tæller op samtidigt. Den en brugt metode er at  bruge en barrier \vref{barrier}.

\begin{lstlisting}[label=barrier,caption=A barrier in PyCSP]
@process
def Barrier(nprocesses, signalIN, signalOUT):
	while True:
		for i in range (nprocesses):
			signalIN()
		for i in range (nprocesses):
			signalOUT(0)
\end{lstlisting}

Barrier blev introduceret i MPI, og sikrer at alle tråde har nået dette punkt før de må fortsætte. 
I PyCSP er det trivielt at have  denne egenskab, da processer til begge kanalender er klar, og med to kanaler kan man sikre at ingen proces modtager et signal før alle processer har sendt et signal til barrieren.

I SimPy er hver customer en process og det vil være nærliggende at 


