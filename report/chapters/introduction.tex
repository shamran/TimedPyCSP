\chapter{Introduktion}
  \section{Problem}	 
  \section{Kontekst - Baggrund og motivation}
Over de siste par år er multi-kerne cpu'er blevet hyldevarer, og er at finde i 
stort set alle computere det sælges nu om dage. For at udnytte den ekstra 
ydelse der er til rådighed med flere kerner, er softwareudviklere nødt til at 
ændre på tankegangen og metoderne der hidtil har været brugt til at udvikle 
programmer. Hvor man tidligere har kunne udvikle programmer ud fra en meget 
sekventiel tankegang, er man nu nødt til at muliggøre samtidig afvikling af 
opgaver, således de kan udnytte flere kerner samtidigt. Dette stiller både krav 
til udviklerne og de værktøjer og sprog de benytter til udvikling.  En metode 
til at repræsentere den krævede samtidighed på, er ved hjælp af 
CSP\cite{hoare-csp}.  I CPS opdeles et program i selvstændige processer, der 
kan afvikles samtidigt på hver sin kerne. Der bør som udgangspunkt ike være 
delt data mellem processer, og al kommunikation mellem processer sker eksplicit 
via kanaler. Dette gør det let at overskue og meget egnet til multi-kerne 
arkitekturer. Ydermere lægger det op til at komplekse systemer opbygges af 
mindre individuelle enheder, og kobles sammen med kanaler for så til sammen at 
udgøre systemet som helhed.
Opdelingen af et program i processer skaber nye problemstillinger, som ikke er 
til stede i sekventielle programmer. Specifikt introduceres der et behov for 
synkronisering af processerne idet de ofte vil have en indbyrdes afhængighed af 
større eller mindre grad. Denne synkronisering kan ske implicit eller eksplicit 
i programmet, afhængig af strukturen i det givne program. Ved eksplicit 
synkronisering forstås at der er i programmet findes elementer hvis primære 
formål er at håndtere synkronisering. Ved implicit synkronisering sker 
synkroniseringen ud fra programmets normale kommunikation mellem processerne, 
og ingen ekstra elementer til håndtering af synkronisering er nødvendige.  

\subsection{usammenhængende råtekst}
Der er, så vidt vi ved, ikke nogen tilgængelige implementationer af CSP der 
tager... 

CSP er tilgængeligt som en udviddelse til en række sprog, heriblandt Java, C++ 
og Python. I Python hedder udviddelsen PyCSP, og er udviklet i et samarbejde 
mellem mellem Tromsø og Københavns Universitet, med henblik på at skabe et 
sprog som er let forståeligt men samtidigt giver den påkrævede mulighed for 
repræsentation af samtidighed.  


Af de implementationer af CSP der findes på nuværende tidspunkt, er der, så 
vidt vi ved, ingen der har en reel repræsentation af tid indbygget. Det gør at 
tidsspecifikke programmer, som f.eks. realtids-simuleringer, kræver brug af 
andre konstruktioner i sproget.
Vi ønsker at undersøge muligheden for at introducere tid som en indbygget del 
af PyCSP for derved at kunne lette implementationen af programmer der i større 
eller mindre grad er bundet op omkring et tidselement. k


I sin nuværende form kræver styring af tid i PyCSP brug af 
barrierer\inline{generelt term eller henvisning til MPI?}. Dette skaber et 
behov for flere kanaler mellem de enkelte processer og de fornødne barrierer, 
samt kald til en barriere når en proces skal vente på at fortsætte.  Dette 
resulterer som helhed i mindre overskuelig kode, hvilket vi mener kan gøres 
mere elegant med indbygget funktionalitet til håndtering af tid. Målet er at 
give mulighed for at integrere relationen til tid direkte i det udviklede 
program, i stedet for at benytte 


  \section{Fremgangsmåde}
  \section{``Summary of contributions''}
  \section{Termer}

\begin{list}{}{}

\item Scheduler findes ikke som et dansk ord, som kan  dække helt det samme. Vi har valgt at bruge ordet skemaplanlægger.
\item I \des beskriver det enkelte \code{event} en begivenhed, og vi vil i dette speciale bruge ordet begivenhed for en event i \des. 
\item realtid: tid mål i sekunder, minutter osv.
\item event: begivenhed
\item Vi har fra koden der vises fjernet kode der ikke er relevant for sammenhængen, som f.eks kald til logging. Linje nr. vil derfor ikke altid passe, men det første linje nr i kodestumpen vil svare til linjenr i source koden.
\end{list}


