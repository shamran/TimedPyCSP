\chapter{Interaktiv planlægning}
\label{chap:is}
\fxwarning{Mangler Evaluering}
\fxwarning{Mangler Opsummering}
Interaktiv planlægning (\is) er det sidste anvendelsesområde vi vil belyse med henblik på at indføre tid i \pycsp. Det har dog vist sig at emnet kun er sparsomt berørt i litteraturen, og der er ikke en klar definition på hvad det er og hvor det anvendes. 
%og at de få definitioner af \is vi har fundet, ikke er et selvstændigt anvendelsområde, men en definition af RTP med en hard deadline uden at være et kritisk system. \cite{?}. 
Vi forventede at dette anvendelsesområde var brugt i forbindelse med computerspil, men efter at have studeret litteraturen, og have rådført os med Lektor Kenny Erleben, der underviser på Det Danske Akademi for Digital Interaktiv Underholdning (DADIU), er vi kommet frem til der ikke findes en udbredt definition af \is. Han fortæller desuden at en af begrundelserne for at computerspilfirmaerne ikke er interesseret i at oplyse om deres metoder til at planlægge begivenheder i spil, er at det  betragtes som en  virksomhedshemmelighed. 

Vi vil derfor i stedet på baggrund af en række praktiske eksempler indkredse hvad vi forventer \is skal kunne bruges til, og på baggrund af eksemplerne se på muligheden for at implementere en model, så eksemplerne kan implementeres i \pycsp. Dette kapitel adskiller sig dermed væsentligt fra de foregående to kapitler, i og med tidsmodellen ikke baserer sig på en fast definition givet af litteraturen og vi ikke bygger på kendt viden.

\section{Eksempler}
Vi har valgt to scenarier som vi forventer med fordel kan benytte \is. Det første er en repræsentation af et ur, hvilket vi mener er det simpleste eksempel der kan gøre brug af \is. Det andet eksempel er en del af et computerspil, som er vores forventede primære anvendelsesområde for \is. 

\subsection{Et ur}
Det første eksempel på \is er en repræsentation af et digitalur. Uret består af fire cifre, og en gang i minuttet skal minuttallet tælles op. Det er et  krav at en opdatering af uret skal sætte uret til at vise det korrekte tidspunkt. Vi forestiller os at uret er en del af et større system hvor der er andre ressourcekrævende begivenheder der er vigtigere at få udført end opdateringen af uret. Opdatering af uret foregår ved at planlægge en begivenhed til hvert minut, der specificerer hvad uret skal vise. Da det har en lav prioritet, er der ikke er nogen garanti for at denne begivenhed indtræffer i det minut den er planlagt til. Derfor skal begivenheden  bortkastes såfremt den overskrider sin deadline. Deadlinen vil være det sidste sekund inden et nyt minut begynder, for at sikre den krævede korrekthed. 

Uret er repræsentativt for \is da der planlægges en række begivenheder der skal foregå i fremtiden, og hvor hver begivenhed også har tilknyttet en deadline.

\subsection{Computerspil}
Et andet eksempel vi mener repræsenterer  \is, er mere realistisk og bunder i vores oprindelige forventning om at \is  var defineret af computerspilindustrien, som en metode til at planlægge hvordan spil kan forløbe. Uden deres definition af \is vil vi i stedet opstille et hypotetisk eksempel. 

Vi forstiller os et computerspil, der er skrevet i \pycsp og hvor hvert element i spillet er en selvstændig proces. I dette computerspil skal der være en fugl, der jævnligt flyver på tværs af skærmen. Fuglen skal starte på et givet tidspunkt og med en fast hastighed bevæge sig over skærmen. Fuglens flugt over skærmen udregnes af to typer processer, baseret på en model der minder om videokomprimering. Den første procestype, er en højprioritets proces der står for udregne positionen af fuglen med  et fast interval. Den anden procestype kan bestå af mange lavprioritetsprocesser. Hver lavprioritetsproces står for en egenskab ved fuglen, som  f.eks. at justere fuglen i forhold til dens position, optimere animationen af fuglen, tilknytte fuglekvidren og andre ikke essentielle egenskaber. Den højtprioriterede proces udføres sjældent men er essentiel at få udført, mens lavprioritetsprocesserne blot skal udføres hvis der er mulighed for det og ellers skal droppes.

Uden tab af generelitet vil vi i dette eksempel begrænse os til at fokusere på en høj og en lavprioritets proces. Højprioritetsprocessen står for at beregne positionen mens lavprioritetsprocessen står for at flytte fuglen i forhold denne position.

\section{Beskrivelse}
Ud fra eksemplerne kan vi se på hvilke egenskaber de har, og hvilke krav de derved stiller for at kunne håndteres i et programmeringssprog. Først og fremmest ligger det inden for realtid ligesom RTP. Ligeledes skal der være mulighed for at tilknytte en deadline til en begivenhed. Dette vil i vores opstillede eksempler være hard deadlines, men vi kan ikke udelukke at der findes eksempler hvor andre typer deadlines vil være fordelagtige. Eksemplet med computerspillet viser at der er behov for at tilknytte en prioritet, der er uafhængig af deadline, til en begivenhed. Dette har vi diskuteret som en mulig udvidelse til RTP i \cref{sec:deadlineFuture}. Disse egenskaber minder alle om dem der er er givet for RTP. Ud over disse skal vi også kunne tilknytte et starttidspunkt til en begivenhed. Det lægger sig mere op af \des med det forbehold at vi i \is ikke garanterer at en begivenhed sker på et bestemt tidspunkt, men tidligst på det angivne tidspunkt.  

Vi kan dermed se \is som en blanding af RTP og \des, med tidsmodellen og deadlines fra RTP, og startidspunkter fra \des. 

%\is arbejder ligesom RTP i realtid. Desuden minder de også om hinanden da man i begge modeller arbejder med begivenheder, der har tilknyttet deadlines. For det tredje viser computerspilseksemplet at en udvikleren skal kunne tilknyttes prioriteter til begivenheder, der skal sættes uafhængigt af deres deadline i \is. Dette nævnte vi som en mulig udvidelse til RTP i \cref{sec:deadlineFuture}.

%\is og \des minder også om hinanden da man i begge modeller skal kunne planlægge en begivenhed til at foregå ud i fremtiden. Men hvor \des kan garantere at begivenheden sker på præcist det angivne tidspunkt kan vi i \is kun garantere at det sker efter et givent tidspunkt.

\section{Design og implementering} 
Vi argumenterer i kapitel \ref{chap:des} for at planlægning af begivenheder til et givet tidspunkt, kan tolkes som venten indtil tidspunktet. Vi kan derfor se \is som RTP med den yderligere mulighed at kunne vente. Som nævnt ovenfor vil det også være et krav at vi kan sætte en prioritet på en proces uafhængigt at processens deadline. 

Da kravene til \is rent teoretisk ligger meget tæt op ad de løsninger vi tidligere har beskrevet, vil vi også tage udgangspunkt i de allerede udviklede implementeringer. 

%I \des kom vi frem til at planlægningen af begivenheder ud i fremtiden også kan tolkes som en venten. Dermed kan man se på \is som en udvidelse til RTP, hvor man udover at have mulighed for at sætte en deadline skal have mulighed for at vente. For at kunne bruge RTP til \is vil det desuden være hensigtsmæssigt at  udvide RTP så det er muligt for udvikleren at tilknytte en prioritet til begivenheden.

\subsection{Funktionerne \code{Now} og \code{Wait}}
Som vi beskrev i \des introducerede vi de to globale funktioner \code{Now} og \code{Wait} der hhv. returnerer den aktuelle tid og lader en proces vente i et givent tidsrum. Vi har ændret den interne implementering af funktionerne, så de bruger realtid. Ved at genbruge de samme funktioner, sikres en ensartet implementering af tid på tværs af TimedPyCSP, og man kan i vores øjne med fordel tilføje dem til alle \pycsp versionerne, for på den måde at ensrette de forskellige implementeringer. Hvis \code{Now} og \code{Wait} blev inkluderet i \code{greenlets}-versionen kunne de fjernes helt i \is, da de to baserer sig på den samme tidsmodel.

For at benytte realtid i forhold til diskret tid bruger vi pythons \code{time} modul. Genimplementering består derfor kun i at ændre funktionen \code{Now} til at bede \code{time}-modulet om tiden i stedet for \sched en.

\subsection{Udvikler"-prioriteter}
I computerspilseksemplet, har processerne forskellige prioritet dikteret af udvikleren. Denne prioritet er ikke det samme som den prioritet der allerede findes i RTP, da denne  er beregnet af \sched en. For at adskille dem vil vi kalde prioriteterne der er angivet af udvikleren for udvikler-prioritet. Vi skal udvide RTP således at det kan håndtere processer, der både kan have deadlines og udvikler"-prioriteter tilknyttet. Dette har vi allerede beskæftiget os med i \cref{sec:deadlineFuture}, som en fremtidsmulighed, og passer derfor godt sammen med RTP.

Først skal det fastlægges i hvilket interval udvikler-prioriteter kan antage. Vi ønsker ikke at begrænse udvikleren ved at have for få prioriteter, men omvendt reduceres \sched ens  mulighed for at udvælge processer hvis hver proces har sin egen unikke prioritet. Hvis en udvikler kan vælge mellem et stort antal prioriteter risikere man også at introducere en prioritetsskrue. Dette sker hvis en udvikler flere gange undervejs i udviklingen af et program øger den maksimale prioritet, da han mener sin nuværende proces er den vigtigste uden at gennemtænke det i relation til alle andre processer. Dermed risikere man at udvande prioriteten de allerede udviklede processer.  Der skal derfor være en maksimal prioritet, og intervallet man kan angive prioriteter i, må ikke være så stort at processerne for unikke prioriteter.

Præcis  hvor stort intervallet skal være for udvikler"-prioriteter, kræver dog en bredere analyse af flere projekter, og vi vil derfor begrænse os til at lave et foreløbigt interval på ti, man senere nemt vil kunne ændre baseret på en bedre analyse.


I \code{RTP}-versionen er \sched en en EDF algoritme, som kun planlægger processerne på basis af deres deadline. Vi kan derfor ikke bruge den samme skemaplanlægningsalgoritme, men skal udvide \sched en. For at udvide \sched en skal vi definere den indbyrdes relation mellem deadlines og udvikler"-prioriteter. Baseret på eksemplet kan vi se at de processer der har  tilknyttet en udvikler"-prioritet skal gå forud for både de processer der har tilknyttet en deadlines og dem uden noget. 

I RTP  indeholder \sched en alle processer med en prioritet i en enkelt hob kaldet \code{has\_priority}. Vi kan enten udvide denne hob til en liste af hobe, en for hver prioritet. Med en liste af hobe vil hver hob være mindre og dermed vil de enkelte operationer på hoben være hurtigere. \Sched en kan desuden bruge EDF på hver hob da alle processerne i hver hob har samme prioritet. Til at udvælge hvilken hob der skal udvælges en proces fra løbes listen igennem efter den hob med de højst prioriterede processer, der har elementer. 

Alternativt kan vi udvide den ene hob, der allerede findes så alle processer, både med og uden udvikler"-prioritet befinder sig i den samme hob. Med denne metode kan man ikke bruge EDF, men der skal udvikles en  funktion der kombinere  udvikler"-prioriteten og deadlinen, til en endelig prioritet. Man vil så kunne bruge en Least Priority First (LPF) algoritme, der fuldstændigt svare til EDF, men bruger prioritet til at basere udvælgelsen. I sagens natur vil denne hob  være større end hvis man brugte en liste af hobe. Dette er dog ikke et stort problem, da hoben gemme data i en træstruktur og  søgetiden vokser derfor logaritmisk til antallet af elementer. Vi antager derfor at forskellen mellem de to fremgangsmåder ikke vil være nævneværdig, og under alle omstændigheder, vil den ikke være anderledes end i \code{RTP}-versionen, hvor der også kun findes en hob. Fordelen ved kun at bruge en hob er at vi kan genbruge \code{has\_priority} hoben, og  ikke skal lave en større omskrivning af \code{RTP}-versionen. Desuden skal vi ikke lineært gennemløbe en liste af hobe for at finde den først hob med elementer, men kan med det samme starte i den korrekte hob. Endnu en fordel ved denne metode er at vi nemt kan  ændre vores oprindelige antagelse om at prioritet skal gå forud for deadlines, blot ved at ændre på den eksterne funktion der kombinere de to parametre.

Vi mener at fordelene ved kun at have en hob, og muligheden for at kunne ændre på vægtningen af forholdet mellem udvikler-prioritet er større end besparelsen i tid ved at have flere hobe der skal vedligeholdes. Derfor vælger vi  at genbruge bruge \code{has\_priority}, som den eneste hob til  processer der har deadlines og udvikler"-prioritet. Med kun en hob skal vi derfor udvikle en ekstern funktion der kombinerer to tal til en endelig prioritet. Det kombinerede tal skal have den egenskab altid at udvikler"-prioriteten har forrang. Hver at bemærke er at des højere udvikler-prioriteten er des vigtigere er processen. I implementeringen af \code{has\_priority} bruges der en min-hob, hvorfor vi internt invertere udvikler"-prioriteten, så 0 er den højeste prioritet, og processer, hvor udvikleren ikke har angivet en prioritet, sættes til 10.

Vi valgt at implementere en simpelt løsning, hvor  de to tal lægges efter hinanden. Hvis man eksempelvis har en udvikler"-prioritet på 2 og en deadline på 20, sættes de efter hinanden så den endelige prioritet bliver 220. Dette kan vi gøre da antallet af cifre i hhv. deadlines og udvikler-prioritet ligger fast, så vi ikke risikere en forskydning, når de ligges efter hinanden. For at sikre at processer der har en udvikler"-prioritet, men ingen deadline også kan planlægges, bruges der en kunstig høj deadline. Man vil i vores løsning nemt kunne ændre på måden hvordan de to tal kombineres, blot ved at ændre i en funktion. 


% dikterede valget af \sched at priorite


    
\section{Evaluering}
\section{Fremtidigt arbejde}
Noget om mulighederne for at lave det i proces-versionen af \pycsp.
\section{Konklusion}
