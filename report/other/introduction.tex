\chapter{Introduktion}
I denne opgave vil vi undersøge om det er muligt at introducere tre tidsmodeller i \pycsp. Vi vil identificere de problemstillinger der er forbundet med at skulle foretage denne introduktion og komme med løsningsforslag til hvodan de fundne problemer kan imødekommes. Vi vil fokusere på de praktiske aspekter af problemerne og vil lave en  hel eller delvis implementering, baseret på de givne løsningsforslag, der skal fungere som en udviddelse af \pycsp som det ser ud i dag. For at vise brugen af og fordelene ved vores udviddelse, vil vi lave nogle eksempelprogrammer lavet i \pycsp henholdsvis med og uden vores udviddelser. Dette gøres for at give en klart indblik i hvordan udviddelserne benyttes samt hvilke fordele en introduktion af de givne tidsmodeller direkte i pycsp vil give. 

De tre tidsmodeller som vi vil undersøge er diskretiseret tid, realtid og interaktiv tid. Disse modeller repræsenterer forskellige anvendelser af tid og dækker tilsammen bredt over tid som helhed. Diskretiseret tid anvendes i stor udstrækning i simuleringer specifikt i discrete event sumulation. \\
Realtid benyttes i tidskritiske systemer hvor der er stringente krav om at en given begivenhed er blevet udført inden for en tidsramme. Endeligt bruges interaktiv tid til at specificere at en given begivenhed skal finde sted på et specifikt tidspunkt, eller alternativt inden for en givet tidsrum. 

Så vidt der er muligt ønsker vi at sammenligne vores arbejde med hvad andre har lavet af lignende implementeringer. Dette er ikke første gang der arbejdes med at introducere tid i CSP. Timed CSP er en omfattende teoretisk gennemgang af hvordan tid kan introduceres på det rent teoretiske plan, men det har aldrig vundet indpas i i praktiske implementationer af CSP. Vi vil derfor fokusere på de praktiske aspekter og problemstillinger og dermed ikke tage udgangspunkt i Timed CSP. 

\subsubsection{Rapportens opbygning}
Rapporten vil være strukteret som følger. I \cref{sec:csp} vil vi gennemgå CSP og \pycsp med fokus på de dele der er relevante i forhold til at introducere tidsmodeller. \cref{chap:des,chap:rtp,chap:is} vil være en gennemgang af de tre tidsmodeller, hver med en gennemgang af tidsmodellens anvendelsesområder, eksempler, identificerede problemstillinger, løsninger samt en afsluttende evaluering. Afslutningsvis vil vi foretage en samlet i evaluering og konklusion i \cref{chap:konklusion}




  \section{Problem}	 
  \section{Kontekst - Baggrund og motivation}
Over de sidste par år er multi-kerne cpu'er blevet hyldevarer, og findes i 
stort set alle solgte computere. For at udnytte den ekstra 
ydelse, der er til rådighed med flere kerner, er softwareudviklere nødt til at 
ændre på tankegangen og metoderne, der hidtil har været brugt til at udvikle 
programmer. Hvor man tidligere har kunne udvikle programmer ud fra en meget 
sekventiel tankegang, er man nu nødt til at muliggøre samtidig afvikling af 
opgaver, så de kan udnytte flere kerner samtidigt. Dette stiller både krav 
til udviklerne og de værktøjer og sprog, de benytter til udvikling. CSP er en metode 
til at repræsentere den krævede samtidighed\cite{hoare-csp}. 
\fxnote{omskriv}\begin{shaded}
I CSP opdeles et program i selvstændige processer, der 
kan afvikles samtidigt på hver sin kerne. Der bør som udgangspunkt ike være 
delt data mellem processer, og al kommunikation mellem processer sker eksplicit 
via kanaler. Dette gør det let at overskue og meget egnet til multi-kerne 
arkitekturer. Ydermere lægger det op til at komplekse systemer opbygges af 
mindre individuelle enheder, og kobles sammen med kanaler for så til sammen at 
udgøre systemet som helhed.
Opdelingen af et program i processer skaber nye problemstillinger, som ikke er 
til stede i sekventielle programmer. Specifikt introduceres der et behov for 
synkronisering af processerne idet de ofte vil have en indbyrdes afhængighed af 
større eller mindre grad. Denne synkronisering kan ske implicit eller eksplicit 
i programmet, afhængig af strukturen i det givne program. Ved eksplicit 
synkronisering forstås at der er i programmet findes elementer hvis primære 
formål er at håndtere synkronisering. Ved implicit synkronisering sker 
synkroniseringen ud fra programmets normale kommunikation mellem processerne, 
og ingen ekstra elementer til håndtering af synkronisering er nødvendige.  
\end{shaded}
\fxnote[inline,nomargin]{Mere her, bl.a. om tidsmodeller}
\subsection{usammenhængende råtekst}
Der er, så vidt vi ved, ikke nogen tilgængelige implementationer af CSP der 
tager... 

Af de implementationer af CSP der findes på nuværende tidspunkt, er der, så 
vidt vi ved, ingen der har en reel repræsentation af tid indbygget. Det gør at 
tidsspecifikke programmer, som f.eks. realtids-simuleringer, kræver brug af 
andre konstruktioner i sproget.
Vi ønsker at undersøge muligheden for at introducere tid som en indbygget del 
af PyCSP for derved at kunne lette implementationen af programmer der i større 
eller mindre grad er bundet op omkring et tidselement. 


I sin nuværende form kræver styring af tid i PyCSP brug af 
barrierer. Dette skaber et 
behov for flere kanaler mellem de enkelte processer og de fornødne barrierer, 
samt kald til en barriere når en proces skal vente på at fortsætte.  Dette 
resulterer som helhed i mindre overskuelig kode, hvilket vi mener kan gøres 
mere elegant med indbygget funktionalitet til håndtering af tid. Målet er at 
give mulighed for at integrere relationen til tid direkte i det udviklede 
program, i stedet for at benytte 

\section{Fremgangsmåde}
\section{Vores bidrag}
\section{Termer}

\begin{list}{}{}
\tightlist
\item Scheduler findes ikke som et dansk ord, som kan  dække helt det samme. Vi har valgt at bruge ordet skemaplanlægger.
\item I \des beskriver det enkelte \code{event} en begivenhed, og vi vil i dette speciale bruge ordet begivenhed for en event i \des. 
\item realtid: tid mål i sekunder, minutter osv. TODO: TJEK FOR reel tid.
\item simulering ikke simulation
\item implementering ikke implementation.
\item event: begivenhed
\item Vi har fra koden der vises fjernet kode der ikke er relevant for sammenhængen, som f.eks kald til logging. Linje nr. vil derfor ikke altid passe, men det første linje nr i kodestumpen vil svare til linjenr i source koden.
\item hvad skal emphs og hvad skal med stå med code osv.
\item TODO: vi skal søge og styr på  greenlet vs. greenlets
\item søg igennem grenelts og varianter
\item SKIP-guard, skip-guard \code{skip-guard}? træf et valg mht. både skip og timeout. 
\end{list}


Vi vil bruge tekst markeret med \code{skrivemaskine-font} til at markere variabelnavne, funktioner,  klasser og moduler  der er  der er specifikt for Python.

