\section{Realtime planlægning i \pycsp}
\label{sec:rtp-pycsp}
\fxwarning{Skriv afsnit om udvælgelse af kanal efter prioritet}

Da vi ønsker at introducere RTP i \pycsp er der er række forhold som vi skal tage højde for. Vi vil i dette afsnit tage udgangspunkt i de ovenstående opstillede muligheder og sammenholde dem med \pycsp. 

I \pycsp kan vi anskue processerne som begivenheder, og derved bruge skemaplanlæggeren i greenlets-versionen til at styre hvilken proces og dermed hvilken begivenhed der udføres. Vi har ikke umiddelbart informationer om hvor lang tid en proces er om at blive udført, og det vil kræve en analyse af den enkelte proces at udlede estimater for det. Vi har valgt at fokusere på selve planlægningen af processerne og ikke analyse af processerne. Dermed har vi ikke mulighed for både at benytte RM og LL algoritmerne da de begge benytter information om udførselstiden for en proces. Derved har vi EDF tilbage som mulighed, hvilket er den algoritme som vi vil implementere. En udviddelse af \pycsp til at benytte EDF er forholdsvis ligetil. Der skal laves en mulighed for at brugeren kan angive en deadline til en proces, og vi skal ved kontekstskift sikre at vi aktiverer den proces der har den førstkomne deadline. \pycsp har per definition interne afhængigheder mellem processerne i form af kommunikation over kanaler, og vi kan derfor opleve problemer med prioritetsinvertering. Vi skal derfor også implementere prioritetsnedarvning for at sikre os mod prioritetsinvertering. Endeligt skal vi håndtere overskredne deadlines.

Da vi benytter os af greenlets-versionen af \pycsp arbejder vi med en skemaplanlægger der ikke kan foretage preemptive kontekstskift. Dette kan lede til problemstillinger som det illustreret på \cref{fig:edf-nonpreemptive}. En metode til at mindske denne type problemer er at lade de enkelte processer afgive kontrollen med jævne melemrum. Herved vil der blive foretaget en ny evaluering om hvilken proces der skal aktiveres, og hvis der processer der har en nærmere deadline som er blevet klar, aktiveres en af disse. Dette beror helt og holdent på hver at hver enkelt proces frivilligt afgiver kontrollen og gør det med jævne mellemrum når den er aktiv. Dette betyder at det er overladt til udvikleren at indsætte det på relevante steder i processens kode. 



% Nedenstående beskrives i implementationen
%Vi har valgt at abstrahere en deadline til en prioritet, da vi hermed åbner for senere at kunne lade andre faktorer indgå i prioriteten end blot en proces' deadline. 

begrænset forhåndsviden 
  dynamisk planlægning
  ingen viden om udførselstid - heller ikke estimater  

non-preemptive (snakkes der ikke om i foregående afsnit)

nedarvning
  any->any kanaler kan potentielt give stor spredning af prioritet

\subsection{Prioritetsnedarvning}
At introducere prioritetsnedarvning i \pycsp virker umiddelbart ligetil idet vi kan se de indbyrdes afhængigheder klart ud fra forbindelserne gennem kanaler. Der kan forekomme andre afhængigheder som er mindre synlige, men vi mener ikke disse vil forekomme i velskrevne CSP applikationer, og vi har derfor valgt at begrænse os til afhængigheder repræsenteret vha. kanaler. På trods af den umiddelbare simplicitet er der dog adskillige overvejelser bl.a. med henblik på hvilke konstruktioner i \pycsp der skal arve prioriteter, hvornår de skal arve dem og hvor længe de skal beholde den modificerede prioritet. \\

\subsubsection*{Ændring af prioritet}
Det er væsentligt at overveje hvornår det er nødvendigt at foretage prioritetsnedarvning. Vi arbejder med et dynamisk system af processer, hvor en proces, afhængig af dens tilstand, er afhængig af forskellige andre processer for at kunne arbejde videre. Hvis vi højner prioriteten på alle processer der er forbundet til en proces med høj prioritet vil mange af processerne der arver den høje prioritet reelt ikke kunne bidrage til udførelsen af den proces der starter med høj prioritet. Det er en bedre løsning at det kun er den eller de processer der kan sikre videre udførsel af den aktuelle proces der tildeles højere prioritet. Hvis eksempelvis en proces med høj prioritet ønsker at skrive på en kanal, skal alle processer der læser på den kanal arve den høje prioritet, men processer som ønsker at skrive til en anden kanal som processen med høj prioritet læser fra, skal ikke arve den høje prioritet. Dette vil selvfølgelig ændre sig lige så snart processen har fået skrevet på kanalen og derefter befinder sig i en anden tilstand og er afhængig af noget andet for at komme videre i sin udførsel. \\
Ud fra dette kan vi også se at så snart, det midlertidige afhængighedsforhold ophører skal processer der har arvet en prioritet miste denne. Der skal selvfølgelig tages højde for at en proces kan arve forskellige prioriteter fra forskellige andre processer, så det skal være muligt at falde tilbage til den næsthøjeste arvede prioritet, i stedet for blot at skifte tilbage til den oprindelige prioritet. 

\subsubsection*{Begrænsning af nedarvning}
Vi har som nævnt en klar kæde af afhængigheder i \pycsp men vi skal være opmærksomme på ikke at højne processers prioritet unødigt. Dette kan let være tilfældet såfremt vi ikke holder ordentligt styr på hvorfor en proces har den prioritet den har, om den er sat af udvikleren eller den er nedarvet. Man kan forestille sig en situation hvor et uddrag af et proces-neværk består af en generator-forbruger model med to generatorer og en enkelt forbruger. De to generatorer er forbundet til forbrugeren vha. en \code{alternation} og generatorerne har henholdsvis høj og lav prioritet. Forbrugeren vil i dette scenarie arve den høje prioritet fra den tilsvarende generator, men utilsigtet vil den høje prioritet også propagere fra forbrugeren til generatoren med lav prioritet. Dette er ikke hensigtsmæssigt da de to generatorer nu har lige høj prioritet og ikke det forhold som udvikleren oprindeligt har angivet. Dette problem kan løses ved at indføre en enkelt restriktion af prioritetsnedarvning, hvilket er ensretning af nedarvningen med henblik på om der skal læses eller skrives til en kanal. Det vil sige at en proces der arver en høj prioritet fordi den skal læse fra en proces med højere prioritet, som i førnævnte generator-forbruger model, kun propagerer den høje prioritet videre til processer som den skal skrive til. Derved udgår vi den uhensigtsmæssige tilbageførelse af prioritet samtidig med at vi bibeholder nedarvning frem i systemet.

\subsubsection{noter}
Skelne mellem read og write
måske skal en kanal arve prioritet?
hvornår skal prioriteten ændres? 

2 cases:
udvælgelse i alternation
propagering af prioritet

med nedarvning kan en proces uden deadline arve en høj prioritet uden at få sat en deadline. 

Skal processer der arver prioritet også arve deadline? Det skal de nok ikke, da de så kommer til at kaste exceptions selv på deadlines som brugeren ikke har sat. De skal nok kastes af den oprindelige proces med information om hvad den ventede på da den fejlede. 

\subsection{Tilknytning og overskridelse af deadlines}
Som udgangspunkt skal vi kunne håndtere at en proces kan have forskellige typer deadlines. Umiddelbart giver det mening at der for hver proces tilknyttes en deadline samt hvilken type det er. Dette giver mulighed for at vi kan differentiere i måden hvorpå vi håndterer en overskreden deadline. F.eks. kan vi stoppe systemet helt i tilfælde af overskridelse af en kritisk deadline, kaste en exception ved en hard deadline og blot registrere overskridelser af soft deadlines. Uanset hvilken handling vi vælger at tilknytte til de respektive overskridelser, vil der være situationer hvor den vlagte handling ikke er optimal. Vi har derfor valgt en anden løsning hvor en proces blot kaster en exception hvis den overskrider en deadline. Dette overflødiggør at der tilknyttes en specifik type deadline til en proces, da håndteringen af den kastede exception overgives til udvikleren. Det er herved op til den nekelte udvikler at definere hvad der skal ske i i hver enkelt proces såfremt den oplever en overskreden deadline. Dette giver den største frihed til at tilpasse håndteringen til den enkelte proces og applikation. 

\begin{shaded}
\subsection{Blokkerede processer}
I den teoretiske tilgang til RTP antages det ofte at processerne er periodiske, har en fast eksekverings tid per periode og er uafhængig af andre processer, og køres i et isoleret miljø. De forskellige tilgange til RTP fokuserer på hvordan man kan overvinde de enkelte antagelser ved isoleret og ophæve en af begrænsningerne. 


Dette er en højst idealiseret verden og i en introduktion af RTP i PyCSP vil processerne ikke overholde et eneste af disse antagelser. 
I \pycsp bruges rendezvous til at blokere kommunikerende processer.

Vi vil nu beskrive problemerne ved at processerne er afhængige af hinanden, og kan blokere hinanden, således at en proces med høj prioritet venter på processer med lavere prioritet. Forestil dig i \pycsp tre processer ($P_0,P_1,P_2$)med prioriteterne $Pr_0>Pr_1>Pr_2$. Først udvælges $P_0$ da denne har højst prioritet, men stopper da den skal kommunikere med $P_2$. Den næste proces der udvælges vil være $P_1$, og dermed bliver $P_0$ unødigt forsinket mens $P_1$ kører. Dette kaldes priority inversion\cite{sha1990priority}.

Der findes overordnet set to metoder til at løse problemet med priority inversion. Enten kan man ungå at blokere processer, eller man kan benytte priority inherience\cite{sha1990priority}. Med \pycsp kan man ikke ungå at processer kommunikere, og dermed vil kunne blokere hvorfor priority inherience er den enste farbare vej hvis man skal sikre optimal planlægning.
\end{shaded}


