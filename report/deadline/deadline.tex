\chapter{\ds}
\inline{Måske skal vi ikke snakke om deadline \sched ning men om real time scheduling hvor deadline er en af dem.}
Vi vil i dette kapitel beskrive Real-time systemer, der står for \sched ning i realtid samt  hvordan \sched eren kan planlægge processerne så vi sikre processer kan køre rettidigt baseret på deres prioritet og deadline.

I den nuværende \csp er alle processer lige, hvilket giver den bedste udnyttelsen af systemet. Det er dog ikke altid hensigtmæssigt kun at maksimere den globale ydelse.\fxnote*{Bedre forumulering}{Eksempelvis vil programmer der skal håndtere GUI, og bruger input ønske  at grænsefladen altid  reagere selv under høj belastning.} Alternativt kan fejl der opstår i systemet, skulle håndteres med det samme. 

En Real-time planlægger (RTP) kan derfor være relevant og bruges allerede i  indlejerede systemer til f.eks medicinsk udstyr men bruges også i f.eks kontrol af luftrummet,  processkontrol samt på rumstationen ISS\cite{Audsley1990}. Det er  relevant  hvis der findes flere processer der ønsker at udføre deres arbejde samtidigt og hvor programmets succes afhænger af timingen for hvornår processerne udføres. Til at beskrive denne timing er der i de fleste RTP tilknyttet en deadline til processerne.

Indefor RTP findes der flere underkategorier som alle har tilknyttet en deadline, men varrierer i hvordan denne deadline skal fortolkes. Man kan illustret de forskellige kategorier med time-value funktioner. Her repræsentererer ``værdien'' det fremskridt den enkelte proces bidrager med til det endelige mål for programmet.

I \cref{fig:hard-dl} vises en hard deadline for en process. 
\begin{figure}
 \begin{center}
  \includegraphics[scale=0.75]{images/hard-deadline}
	\caption{Proces med hard deadline.}
	\label{fig:hard-dl}
\end{center}
\end{figure}
Her tilføres der en positiv værdi til programmet hvis processen afsluttes mellem dens starttidspunkt og dens deadline. Hvis processen først er færdig efter deadline har den ingen værdi. En soft deadline (\cref{figure:soft-dl}) tilføjer den samme værdi som en hard deadline hvis procesessen bliver færdig rettidigt. 
\begin{figure}
 \begin{center}
  \includegraphics[scale=0.75]{images/soft-deadline}
	\caption{Proces med soft deadline.}
	\label{figure:soft-dl}
\end{center}
\end{figure}
Hvis deadlinen overskrides mindskes værdien den proces tilføjer, omvendt propotionalt med overskridelsen. Ved en hard deadline er der ikke tilknyttet en egentligt straf hvis en proces ikke overholde sin deadline. Dette er derimod tilfældet i \cref{fig:hard-rtp}, der viser en proces der tilføjer negativ værdi ved overtrædelse af en deadline. Hvis den tilknyttede straf for ikke at overholde en deadline er større end en hvad programmet maksimalt kan opnå ved at overholde alle deadlines kaldes det et ``hard real-time system''\cite{Laprie1989}.
\begin{figure}
 \begin{center}
  \includegraphics[scale=0.75]{images/critical-deadline}
	\caption{Proces med kritisk deadline.}
	\label{fig:hard-rtp}
\end{center}
\end{figure}

Generelt vil der i et real-time system ikke være alle processer der har den samme type af deadline. Nogle processer har ingen deadline, nogle har en soft deadline, og få har en hard deadline. For RTP skal kørslen planlægges så processerne har den maksimale udnyttelse af tilgængelige ressourcer samtidigt med at alle deadlines overholdes.

\section{Beskrivelse/teori}
De fleste eksisterende real-time systemer arbejder på isolerede systemer, hvor planlæggeren har fuld kontrol over hele computeren. Derfor er hovedparten af forskningen indefor det praktiske område gået til udarbejdelsen af specialisere kerner og totale operativsystemer\cite{damm1989real, jones1979staros, levi1989maruti,ramamritham14scheduling}. Vi ønsker i modsætning hertil ikke at udvikle en specialiseret kerne, men lade \sched en i \pycsp kunne planlægge processer efter bedste evne baseret på informationer den har om processerne.

For real-time systemer kan processerne enten planlægges statisk eller dynamisk\cite{cheng1987scheduling}. I statisk er alle processer er kendt på forhånd. Planlæggeren kan i dette tilfælde allerede inden start udregne om det er muligt at overholde alle deadlines. Alternativt planlægges processerne dynamisk hvis der  løbende kan ankomme nye  processer der skal planlægges. I real time systemer er næsten alle processer cykliske, med enten en regelmæssig eller tilfældigt periode. Periodiske processer kan være målinger der skal være foretaget med regemæssige intervaller, mens aperiodiske processer kan forekomme som reaktion på udefra kommende begivenheder, eller være fejl, der hurtigt skal håndteres inden systemet kan fortsætte.
Til planlægningen har planlæggeren behov for at vide hvor lang tid det vil tage at udføre en given proces per periode, men da dette tal enten ikke kan kendt eller fast for hver periode bruges der ofte estimater. Dette medfører at en aperiodisk proces kan ankomme på et vilkårligt tidspunkt og da planlæggeren kun har et estimat for tidsforbruget kan man  ikke tilknytte en ``hard deadline'' til aperiodiske processer da der altid findes en kæde af aperiodiske processer der medføre en overskridelse af en deadline. 
\fxnote*{Dette skal måske flyttes eller omformuleres så vi ikke med det samme begrænses til dynamiske \sched}{I \pycsp kan der til alle tidspunkter tilføjes nye processer, og derfor vil vi kun beskæftige os med en dynamisk \sched. Desuden har man ikke med \pycsp fuld kontrol over hele operativsystemet. Mængden af processerkraft vi har til rådighed til kørsel af processerne vil derfor varriere uafhængigt af \pycsp, hvorfor vi heller ikke kan lave et pålidelig ``hard real-time system'', men fokusere på et ``soft real-time system''.}

\subsection{Forskellige \sched e}
Vi vil i dette afsnit fokusere på \sched e i et ``soft real time'' system,   hvor processer ankommer dynamisk og diskutere fordele og ulemper ved dem.
To af de mest kendte \sched e til brug i real-time systemer er ``Rate monotonic algorithm''\cite{lehoczky1989rate,liu1973scheduling} og ``Earliest deadline first''\cite{liu1973scheduling}.

Hvor processer isoleret set har behov for at udføre deres opgave inden deres deadline, har \sched en behov for kvantetativt at kunne \fxnote{brugere sortere ?}{organisere} dem indbyrdes således den til hver tid kan vælge hvilken proces der næste gang skal udføres. Kernen i en  \sched ~ er derfor at gå fra en række processer med tilknyttet deadline og eventuelt andre egenskaber til en prioriteret liste 

De klassiske algoritimer behandler alle processer som værende ligeværdige. Vi har dog tidligere vist at processer kunne reagere forskelligt på en overskridelse af deres deadline. En \sched er stabil hvis man kan definere en mindre mængde processer som kritisk, og som deadline vil bliver overholdt selv hvis alle deadlines ikke kan overholdes.

\subsubsection{Rate monotonic algorithm (RM)}
RM er oprindeligt en statisk \sched, der fra start af udregner en prioritede liste på baggrund af frekvensen af processens periode, dermed vil processer der oftet skal have udført deres periode en højere prioritet, end processer med lav frekvens. RM er todelt og i første del udføres før selve simuleringen udregnes  prioriteten for processerne, og udvælger hvilke processer der kan medtages i selve udførslen. Anden del står for udvælgelsen af processer  under simuleringen, og her vælges simpelt den proces med den højeste prioritet. 

 Et problem for RM er at ved udvælgelsen af processer der kan medtages har man ikke en optimal udnyttelsen af processorkraf. \Citeauthor{lehoczky1989rate} er kommet frem til at ``worst-case'' er udnyttelsen i gennemsnit 88\%\cite{lehoczky1989rate}. Et større problem i relation til implementering i \pycsp er dog at RM er dog at den er statisk. Til gengæld er algoritmen stabil ved en overskridelse af deadline for en proces. 

\subsubsection{Earliest deadline first (ED)}
Som alternativ til den statiske \sched, hvor man ikke kan ændre prioriten af processen løbende gennem simuleringe, findes de dynamiske \sched er, hvor er ED er et eksempel. Her evalueres prioriterne af processerne dynamisk igennem simuleringen og evaluere dermed løbende hvilke processer der skal udvælges. I ED har den proces hvis deadline ligger tættest på højest prioritet og den hvis proces har længst til deadline den laveste prioritet. Aperiodiske processer kan i ED indgå på lige fod med de periodiske da man til hvert processkift evaluere hvilken der har den nærmeste deadline, som både kan være en periodisk proces som en aperiodisk.

Udnyttelsen af processorkraft kan i ED komme op på 100\%, da alle processer bliver planlagt løbende i modsætning til RM der foretager et valg om en given proces kan planlægges.  Ulempen ved ED er den ikke er stabil i det vi ikke har kontrol over hvilke processers deadline der bliver overskredet. Dette er specielt et problem hvis man har en en uhomogen samling processer hvor en mindre del er kritiske.

\subsection{Blokkerede processer}
I den teoretiske tilgang til RTP antages det ofter at processerne er periodiske, har en fast eksekverings tid per periode og er uafhængig af andre processer, og køres i et isoleret miljø. De forskellige tilgange til RTP fokusere på hvordan man kan overvinde de enkelte antagelser ved isoleret og ophæve en af begrænsningerne.

Dette er en højst idealiseret verden og i en introduktion af RTP i PyCSP vil processerne ikke overholde et eneste af disse antagelser. 
I \pycsp bruges rendezvous til at blokerer kommunikerende  processer.

Vi vil nu beskrive problemerne ved at processerne er afhængige af hinanden, og kan blokere hinanden, således at en proces med høj prioritet venter på processer med lavere prioritet. Forestil dig i \pycsp tre processer ($P_0,P_1,P_2$)med prioriteterne $Pr_0>Pr_1>Pr_2$. Først udvælges $P_0$ da denne har højst prioritet, men stopper da den skal kommunikere med $P_2$. Den næste proces der udvælges vil være $P_1$, og dermed bliver $P_0$ unødigt forsinket mens $P_1$ kører. Dette kaldes priority inversion\cite{sha1990priority}.

Der findes overordnet set to metoder til at løse problemet med priority inversion. Enten kan man ungå at blokerer processer, eller man kan benytte priority inherience\cite{sha1990priority}. Med \pycsp kan man ikke ungå at processer kommunikere, og dermed vil kunne blokere hvorfor priority inherience er den enste farbare vej hvis man skal sikre optimal planlægning.

  \section{Eksempel}
  \section{Design og implementation}
  \section{Evaluering}
  \section{Fremtidigt arbejde}
  \section{Opsummering}
