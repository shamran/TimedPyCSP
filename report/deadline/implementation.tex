\section{Implementering}

\subsubsection{Now og Wait}
Som vi beskrev i \des introducerede vi de to globale funktioner Now og Wait der hhv. returnedere tiden og fik en proces til at vente i et givent tidsrum. Vi har ændret den interne implementation af funktionerne, så de bruger realtid, og bruge funktionen Now alle steder hvor tiden skal bruges i stedet  for direkte at bruge pythons funktionalitet til at bestemme time. Dette sikre en ensartet implementering af time på tværs af de tre udviklede versioner af TimedPyCSP.

\subsubsection{Overskrednen deadlines}
Planlægning i realtime kræver beslutning for hvordan  overskredne deadlines skal håndteres. Man kan vælge enten at se det som en egenskab for processen hvor dens deadline enten kan være overholdt eller ej. Alternativt kan der kan en overskredenent deadline resultere i en exception.

Hvilken metode der egner sig bedst til RTP afhænger af hvilken deadline der er tilknyttet processen. Er der tilknyttet en soft deadline til en proces, vil processen stadig tilføje værdi til systemet, selvom det  overskrider dens deadline. I det tilfælde er det stadig bedst at systemet hurtigst mulig gør processen færdig, således den størst mulige værdi tilføjes systemet. Derfor skal systemet blot markere at dens deadline er overskredet. Senere må programmøren så manuelt håndtere at processens deadline er overskredet. 


Hvis en process har tilknyttet  en hard deadline, vil en overskredet deadline  ikke tilføje værdi til systemet og derfor kan det ikke betale sig for systemet at lade processen blive færdig. processen skal derimod stoppes hurtigst muligt, så systemet istedet kan processere processer hvis deadline endnu ikke er overskredet. For et system hvor processerne har hard deadlines vil det derfor være bedst hvis en overskredet deadline resulterede i en exception, der med det samme stopper processen og lader programmøren bestemme hvodan processen skal forholde sig til at deadlinen er overskredet.

Vi har valgt at der i vores system skal kaldes en exception hvis en deadline overskrides. Dette er er gjort ud fra en betragtning om at systemet ikke kender konsekvensen af en overskredet deadline, og derfor må det være programmørens ansvar at håndtere processen.  Hvis processen stadig kan bidrage med værdi, kan programmøren lade processen fortsætte sin kørsel, og alternativ kan processen lukkes korrekt ned. Ulempen ved at kalde en exception er at processen stopper sin eksekvering i utide. Dette giver problemer f.eks. hvis processen er tilknyttet en kanal og venter på at kommunikere.  Kanalen holder en styr på antallet af processer der vil kommunikere. Hvis processen pludseligt forsvinder vil tilstandsvariablerne ikke være sat korrekt. det er derfor vigtigt at processen manuelt rydder op efter sig selv i forbindelse med en exception, da det ellers kan resultere i et ustabilt system.

I en fremtidig version, vil man kunne udvidde muligheden med et hybrid der både kunne håndtere at markere processerne og kalde en exception. Processen kunne f.eks have  tilknyttet hvilken type deadline det var systemet kunne så reagere passende så soft deadlines blev færdigbehandlet mens hard deadlines resulterede i en exception.




\subsubsection{Preempting}

Da vi ikke har mulighed for PyCSP at have preempting, kan  man risikere at en proces med lav prioritet proces og lang kørselstid kan blokere for en proces med høj prioritet, hvis denne ankommer efter processen med lav prioritet er sat i gang. Vi kan ikke fuldstændigt undgå dette, men programmøren kan derimod minimere problemet ved med mellemrum i processerne at afgive kontrollen og at lade  skemaplanlæggeren evaluere hvilken proces der skal have mulighed for videre at kører. Er der ankommet en proces med høj prioritet kan denne få kørselstid, og ellers kan processen med lav prioritet fortsætte dens kørsel. 

Det er programmørens opgave at processen afgiver kontrol, hvorfor det  derfor være nemt at afgive kontrollen fra processen. til dette har vi lavet funktionen \code{Release()} der kan kaldes fra enhver proces. 
Implementeringen er meget simpel og er blot en wrapper funktion, da den underliggende funktionalitet allerede eksisterer. Den aktive proces replanlægges ved at blive lagt på køen for planlæggeren, og planlæggeren vælger derefter den optimale proces der skal udføres. Er der ikke kommet ny processer vil det stadigt være den originale proces der planlægges og den kan umiddelbart fortsætte sin kørsel. Hvis der derimod i mellemtiden er ankommet en ny proces der har højere prioritet, vil denne blive udført i stedet.

\subsubsection{Ændringer i \sched en}
I \code{greenlets} versionen af \sched en findes der som nævnt tidligere tre lister af processer: \code{new}, \code{next} og \code{timers}. De tre lister er prioriteret således at der først kigges på processer fra \code{timers}, dernæst fra \code{new}, og til sidst kigges der i \code{Next}.

I RTP er det ikke hensigtsmæssigt at inddele processerne i disse tre  kategorier. Vi skal derimod have et miljø der gnidningsløst tillader både processer med og uden deadlines, samt at de dynamisk kan ændres. \sched en skal i forbindelses med proces skift hurtigt kunne finde den den næste proces der skal udføres.

Vi har derfor valgt at fjerne  de tre lister og erstatte dem  med \code{has\_priority},  \code{no\_priority} og \code{timers}. \code{has\_priority} og  \code{no\_priority}  bruges til at placere  aktive processer der ønsker at blive udført, mens  \code{timers} bruges som i greenletsversionen , men er ændret til en  hob ligesom det er tilfældet i \des versionen. 

Vigtigt at gøre sig bemærket med processer der ligger i timers  listen er at de enten har kaldt en timeout i forbindelse med en \code{alternation}, eller har kaldt funktionen  \code{Wait}. Her kan man forledes til at tro at processen vil vente i præcist det angivede tidsrum, men dette er kun  muligt i \des versionen. I versionen hvor tiden er reel fortolkes de to funktioner som vent  minimum det tidsrum. I greenletsversionen ønsker man at minimere overskridelsen, for på den måde at emulere at processen venter præcist i tidsrummet man har angivet for så at fortsætte. I RTP formodes at der findes en mængde processer der skal gennemføres inden en deadline hvorfor de alle kæmper om CPU-tid. En proces der har ventet i timers listen skal derfor ikke nødvendigvis udføres med det sammen, da det hele tiden er processen med højst prioritet der skal udføres, uafhængigt af processerne i timers hoben. Processerne bliver derfor først lagt i en af de to andre lister, og efterfølgende vælges den optimale proces.

Til at implementere \code{has\_priority} bruger vi også en hob, men da modulet heapq  kun understøtter min hobe kan vi ikke lave en klassisk prioritet hob, da den skal kunne udtrække processen med maksimal prioritet. Vi har dermed to muligheder, enten kan vi lave vores egen implementering af en maks hob eller ændre vores prioriteter internt så en lav værdi angiver en høj prioritet. Med en egenimplementation har vi en  logisk opbygning af prioriteter, men vi får ikke fordelenen ved den underliggende implementation i direkte C som man opnår ved brug af heapqmodulet. Vælger vi at bruge heapqmodulet skal vi invertere prioritetsbegrebet, så det er den laveste prioritet der udvælges først. Dette er dog ikke et problem  i vores tilfælde og vi kan nemt opnå den ønskede effekt ved at bruge en proces deadline som dens prioritet. Her vil en lav deadline betyde at processen snart skal være færdig hvilket skal resultere i en høj prioritet.
Vi kan derfor blot benytte en proces deadline som dens prioritet og benytte en min hob. Hvis man i en fremtidig version ønsker at processerne kan have en valgfri prioritet, kan man nemt implementere dette ved efterfølgende at mindske den udregnede prioritet, da dette vil resultere i at processen bliver udført tidligere.


\subsubsection*{Udviddelse af Process}

Hver proces skal have mulighed for at få tilknyttet en deadline, og desuden skal det være muligt i forbindelse med prioritetsnedarvning midlertidigt at kunne ændre dens prioritet.

Når en proces bliver udsat for prioritetsnedarvning, skal systemet planlægge processen ifh. til den kunstigte prioritet. Men det er ikke defineret om den kunstige prioritet medfører at systemet kaster en  \code{deadlineException}  hvis  denne overskrides. Ved at kaste en \code{deadlineException} i processer med kunstigte prioritet, kan programmøren se  afhængighedsforholdet processerne imellem, og måske bedre kan debugge hvorfor den originale proces kaster en \code{deadlineException}. 

En anden begrundelse for at lade kunstige priotetet medfører \code{deadlineException} er hvis processerne findes i et generator/arbejder/forbruger netværk. Her kan forbrugeren øge en arbejdes priotet hvis det er påkrævet af forbugeren modtager det endelige arbejde inden en deadline. Hvis denne deadline ikke nås er dataen som arbejderen bearbejde ikke længere relevant og arbejderen bør derfor stoppe det irrelevante arbejde snarest. 

Der er dog flere problemer ved at lade en kunstig priotet medfører en \code{deadlineException}.  Med hensyn til at visualisere afhægighedsforholdet er det ikke givet at den proces der overskrider en deadline, er den der har brugt tiden. 
I eksemplet fra før kræver arbejderen data fra generatoren. Hvis data først bliver sendt fra generatoren umiddelbart før en overskridelse af deadline. Her vil det fremgå som at arbejderen er ansvarlig for overskridelsen og ikke generatoren og dermed kan man ikke bruge \code{deadlineException} til debugging. I CSP findes begrebet traces, som kan bruges til at se et programs forløb. På nuværende tidspunkt arbejdes der allerede med at introducere traces til \pycsp og når dette er færdigt, vil det være et langt at foretrække som værktøj til debugging.

Et andet problem ved at kaste en \code{deadlineException} ved kunstigt lave deadlines, er at processer der ikke er designet med hensyn til at mulig deadlines pludseligt skal kunne håndtere mulige \code{deadlineException}, hvis ikke hele processen skal risikere at stoppe. Alle processer vil derfor skulle udviddes med yderligere kode til fejlhåndtering. Men da det ikke er sikkert programmøren kender den underliggende begrundelse for en given deadline vil han ikke kunne reagere optimalt. Eksempelvis  vil arbejderen fra før, der der modtager en kunstig priotet fra forbrugeren, ikke uden  forhåndviden kunne foretage valget om en \code{deadlineException} betyder den skal sende sit arbejde uafhængigt af hvor langt den er kommet. Stoppe arbejdet til den bliver bedt om at fortsætte. eller smide arbejdet ud og starte bearbejdningen af nyt data.
\begin{itemize}
\tightlist
\item DeadlineException - ok
\item Now ok
\item Release() f.eks i iterationer -ok
\item to køer kaldet has\_priority og no\_priority, og deres brug i funktionen activate
\item Process udvidet med: \\self.inherit\_priotity = []     \\
        self.deadline = None\\
        self.internal\_priority = float("inf")\\
        self.has\_priority = False\\
            if isinstance(arg, pycsp.greenlets.channelend.ChannelEndRead):\\
                arg.channel.\_addReaderProcess(self)\\
            if isinstance(arg, pycsp.greenlets.channelend.ChannelEndWrite):\\
                arg.channel.\_addWriterProcess(self)
\item def Set\_deadline(value,process=None):
\item def Remove\_deadline(process=None):
\item def SetInheritance(process):
\item def ResetInheritance(process):
\item Channel:\\
        self.readerprocesses = []\\
        self.writerprocesses = []

\item Udviddet \_read og \_write
\item Udvidder match
\item     def choose(self) i alternation


\end{itemize}
