\section{Slagterieksempel}
\fxnote{mere intro -  Rasmus hjælp}
Til at illustrere brugen af RTP vil vi tage udgangspunkt i et  problem fra Danish Crown slagteriet, der skal udvikle en beslutningsmodel, for hvordan en robot skal  udskære hver gris. På Danish Crown slagteriet i Horsens foretages udskæringen  grise som beskrevet på deres hjemmeside:

\begin{quote}\textit{``Grisen [\ldots] skal nu skæres i mindre, håndterbare stykker. Det sker i en meget avanceret maskine -- en såkaldt tredeler -- hvor hver halvdel af grisen deles i tre stykker: bov, mellemstykke og skinke. \\ 
\\
Robotten starter med at fotografere hver halvdel. Dataene fra billedet kombineres med ordren og kundens ønsker, hvorefter stykket deles i tre - nøjagtigt afpasset kundens ønsker.''}{ Danish Crowns hjemmeside\footnote{\url{http://www.danishcrown.dk/custom/horsens/3772.asp}}}\end{quote}

Et billede af den automatiske tredeler er vist  på \cref{fig:pig}.  Det har dog vist sig at udskæringen ikke  altid er optimal, da  ca. 10\% af alle grise har et ekstra sæt ribben som der ikke tages højde for. Til at løse dette problem skal robotten kunne bestemme om grisen har et ekstra sæt ribben inden den foretager udskæringen.

\begin{figure}
 \begin{center}
  \includegraphics[scale=0.5]{images/209690-1}
	\caption{Billedet viser i forgrunden  et foto taget af tredeleren til brug for analyse. I baggrunden ses transportbåndet, hvor de halve  grise venter på på at blive udskåret af den automatisk tredeler.}
	\label{fig:pig}
\end{center}
\end{figure}


Slagteriet har placeret kameraet i starten af et transportbåndet mens udskæringsrobotten findes i den anden enden. Der kan være flere svin på transportbåndet på samme tid, og det fremfører svinene i et fast tempo. Dette giver et fast tidsrum fra svinet passerer kameraet til det passerer robotten. Vi har hermed et klassisk RTP system, hvor robotten skal foretage et valg under en hard deadline, da der skal foretages en udskæring.\fxwarning{konsistent brug af gris/svin}

Vi må først se på arbejdsgangen der er involveret i valget af model:
\begin{enumerate}
\tightlist
	\item Et billede bliver taget af svinet mens den passerer kameraet.
	\item Billedet konverteres til en 3D-model af svinet.
	\item 3D-modellen analyseres.
	\item Robotten udvælger hvor udskæringerne skal være på baggrund af analysen, ordren og kundens ønske.
	\item Robotten udskærer grisen.
\end{enumerate}

Man kan se at arbejdsgangen indeholder en  række klart afgrænsede arbejdsområder, som med fordel kan modelleres som selvstændige processer i \pycsp.  Vi har derfor valgt implementere følgende processer: Kamera, Billedekonvertering, 3D-analyse og en udvælgelse og udskæringsproces, hvilket leder til et procesnetværk som vist i \cref{fig:pig-network}.

\begin{figure}
 \begin{center}
  \includegraphics[scale=1]{images/pig-network}
	\caption{Procesnetværk til udskæring af svin på et slagteri.}
	\label{fig:pig-network}
\end{center}
\end{figure}

\subsubsection*{Implementering}
Til at implementere eksemplet i \pycsp, kan vi oprette hvert gris som et objekt og tilknytte et tidspunkt dertil som vi kan bruge som en deadline. Med denne kan hver proces evaluere om grisen har overskredet sin deadline, og i det tilfælde fjerne griseobjektet, og stoppe den videre behandling af det. Da det er ikke angivet hvordan hele processen startes,  antager vi der findes en form for detektor foran kameraet, der opfanger når et svin passerer og som dermed starter processen. 

Når detektoren starter hele processen, opretter den et griseobjektet som den sender til kameraprocessen, samt sender en kopi direkte til udvælgelse og udskæringsprocessen. Dermed ved processen at der ankommer en gris som den skal udskære, og hvis den, inden deadline, får en analyse af grisen, kan den træffe et begrundet valg om hvordan udskæringen skal foretages. Hvis ikke denne analyse findes, bruges blot standardmodellen til at udskære grisen. \CRef{fig:pig-network2} viser det endelige  netværk, hvor detektoren er introduceret, og som sender data til hhv. kameraprocessen og til udvælgelse og udskæringsprocessen. 

\begin{figure}
 \begin{center}
  \includegraphics[scale=1]{images/pig-network2}
	\caption{Procesnetværk med detektor til initiering af hver gris.}
	\label{fig:pig-network2}
\end{center}
\end{figure}

Vi har holdt os tæt op af den virkelige verden, i designet af implementeringen, men da dette er et delvist tænkt eksempel har vi i  sagens natur ikke  adgang til slagteriet og deres maskiner, eller præcis data om grisene. Derfor må vi nødvendigvis simulere store dele af eksemplet. 

De enkelte processer foretager derfor ikke et konkret stykke arbejde, men har  tilknyttet et tal der repræsenteret det tidsrum, som vi forventer arbejdet i processen vil tage. Hver proces simulere istedet arbejdet, i et  normaltfordelt tidsrum omkring det tilknyttede tidsrum.

Detektoren starter processeringen af hver gris. Derfor står detektoren for oprettelsen af griseobjektet, hvori vi også  definerer om den har et ekstra sæt ribben. Denne oplysning bruges af de enkelte processer til at justere tidsrummet bearbejdningen af grisen tager. 

Et problem ved at implementere slagterieksemplet i \pycsp er  grænsefladen mellem verdenen hvor grisene kører på transportbåndet, og  koden. I \code{greenlets}-versionen.   er der kun  en proces  der er aktiv af gangen. Arbejdet i  konverterings- og analyseprocesserne skal derfor stoppe  mens  udskæringsprocessen foretager udskæringen.  Konverterings- og analyseprocesserne  skal dog frivilligt afgive kontrollen, mens grisen er indenfor robottens rækkevidde og hvis de ikke gør, bliver den ikke udskåret. Da dette er uacceptabelt skal systemet ændres så det ikke er den samme applikation der skal stå for alle tre processer. En applikation skrevet i \pycsp skal stå for konvertering og analyse mens en anden skal styre robotten. De to applikationer skal dog kunne kommunikere og  udveksle data, f.eks. igennem en database, harddisk eller anden delt datastruktur. Hvis analysen bliver færdig gemmes den i den delte datastruktur og robotten kan udnytte analysen. Hvis ikke den er klar bruges standardmodellen.    

Som beskrevet i \autoref{chap:csp}, skal udvikleren på baggrund af det konkrete problem  udvælge den optimale \pycsp version. På baggrund af begrænsningerne nævnt vil det derfor ikke være realistisk at vælge \code{greenlets}-versionen, men man bør istedet vælge \code{threads} eller \code{process}-versionen.
% \code{Threads} versionen kræver at koden skal placeres i eksterne moduler for at have muligheden for at kunne kører parallelt, hvorimod \code{process}-versionen naturligt vil have mulighed for at eksekvere processerne parallelt. 

Ved at vælge \code{process}-versionen, vil man kunne kører et vilkårligt antal processer samtidigt, og udnyttet operativsystemet til at afbryde processerne, således de alle samtidigt får en del CPU-tid. Dermed kan alle tre processer kører samtidigt og robotten kan foretage udskæringen. I denne model findes der kun tre processr og dermed kan der kun bearbejdes en gris i konvertering, analysen og Udvælgelse og udskæringsprocessen. Dette sikre at det er de tre  grise nærmest robotten der arbejdes på, men samtidigt betyder det maksimalt er tre grise der kan arbejdes på samtidigt. Man kunne derfor tilføje flere konverterings og analyseprocesser, så man kunne fortage samtidig beregninger af flere grise, men processerne vil kæmpe mod hinanden for CPU-tid, og grisseobjekterne vil kæmpe mod hinanden for at komme igennem netværket uden hensyn til hvilken gris der er nærmest robotten. Selv ved kun tre  processer risikere vi at udvælg og udskæringsprocessen bliver afbrudt af operativsystemet for at lade konvertering eller analyseprocessen arbejde istedet, som potentielt vil kunne resultere i at grisen ikke bliver udskåret.

Der findes derfor fordele og ulemper ved både \code{greenlets}-versionen og \code{process}-versionen. Derfor har vi valgt at implementere begge versioner for så at sammenligne dem RTP-versionen.

I \code{greenlets}-versionen er ``Udvælgelse og udskæringsprocessen'' er reduceret til en IO-proces der modtager grisene og gemmer dem så en anden applikation kan tilgå dem. Til dette har vi valgt at bruge en \code{dictonary} datastruktur til at gemme  hver gris under deres unikke id. Første gang processen modtager en gris gemmes den datastrukturen, så i tilfælde af at analysen ikke bliver færdig vil den anden applikation som minimum vide der kommer en gris. Anden gang den samme gris modtages er det fra analyseprocessen, med det færdige resultat hvorfor  den gamle gris overskrives. Den anden applikation, kan kender derfor til alle grise, uansdet om analysen er blevet rettidigt færdig.


%\subsection{Eksempel 2 - Sensornetværk med høj/lav -prioritet}
%\inline{eks2: skal vise alternation, kan være en sensor som modtager måledata med lav prioritet og som skal sende måledata på opdordring med høj prioritet.}
