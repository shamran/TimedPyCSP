\section{Opsummering}
Vi har i dette kapitel beskrevet RTP og sat det i kontekst med \pycsp. Vi har set på forskellige typer af deadlines, præsenteret flere skemaplanlægningsalgoritmer og ud fra krav og muligheder valgt EDF. 

Denne algoritme er blevet implementeret i \pycsp. Vi har i den forbindelse implementeret prioritetsnedarvning, og intelligent udvælgelse af hvilke processer der først skal kommunikere, hvis der er flere processer med forskellig deadline tilknyttet den samme kanal. \code{RTP}-versionen kræver kun at en udvikler benytter yderligere tre funktionaliteter: \code{Now, Wait} og \code{DeadlineException} udover \pycsp. Vi mener derfor det er simpelt for en udvikler, der allerede kender \pycsp, at bruge vores udvidelse.

Vi har vist brugen af udvidelsen, med et eksempel,  der er inspireret af en reel problemstilling, på et slagteri. Eksemplet er implementeret både ved hjælp af de eksisterende versioner af \pycsp  samt vores udviklede metode, for derved bedst at kunne vise styrker og svagheder, ved vores implementering. Vi kan på baggrund af evalueringen konkludere at vores løsning til dette eksempel ikke levere nævneværdigt bedre resultater end de eksisterende versioner. 
Dette mener vi kan føres tilbage til, at eksemplet ikke er velvalgt, og vi har modelleret det for simpelt med for få processer, der alle har en deadline, og med den samme laxity. Vi har derfor udvidet eksemplet med processer uden deadlines, og kan se at i disse tilfælde er RTP mellem to og tre gange så effektiv som \code{greenlets}-versionen, til at få ført griseobjekter rettidigt gennem procesnetværket.  






