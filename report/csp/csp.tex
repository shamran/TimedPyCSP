\chapter{CSP og PyCSP}
CSP er et sprog til at beskrive uafhængige processer, der udelukkende udveksler information ved at sende og modtage beskeder over eksplicitte kanaler mellem processerne. Det blev introduceret af \citeauthor{hoare-csp} i \citetitle{hoare-csp}\cite{hoare-csp} og ligger til grund for adskillige praktiske implementationer i et udvalg af programmeringssprog, heriblandt Occam, Java, C++ og Python\cite{May1983, jcsp, Brown2007, pycsp}. I Python hedder udviddelsen PyCSP, og er udviklet i et samarbejde mellem mellem Tromsø og Københavns Universitet, med henblik på at kombinere Pythons mulighed for at effektivt og hurtigt at udvikle programmer med CSPs evne til at udtrykke samtidighed\cite{pycsp}. 


\section{Kommunikation mellem processer}
Alt Kommunikationen foregår over kanaler. De nævnte implementationer har forskellige typer kanaler, set med henblik hvordan de forbindes til andre processer. Generelt findes der fire 4 typer af kanaler: one-to-one, any-to-one, one-to-any og any-to-any. Forskellen ligger i hvem og hvor mange der kan læse og skrive til en kanal. Det er klart at any-to-any kanalen er den mest generelle, og har funktionalitet som de andre. Dette er udnyttet i bl.a. PyCSP hvor det er den eneste kanaltype der er til rådighed. Fælles for dem er at processen ikke kender til kanalen og hvilken proces der er i den anden ende af kanalen. Istedet kender processen kun til en  kanalende, som  den enten kan skrive til eller læse fra. Hvis to processer skal kunne både læse fra, og skrive til hinanden, skal der bruges to kanaler, med tilhørende kanalender. 

Kommunikation mellem to processer i CSP kan kun ske når begge processer er klar til at kommunikere. Hvis den ene proces er klar før den anden er den nødt til at vente på at begge er klar. Herefter kan de kommunikere og så fortsætte.

En \code{alternation} er en struktur til at foretage valg omkring kommunikation. En \code{alternation} kan indeholde et vilkårligt antal kanalender, men der kommunikeres kun på en af dem. Ligesom ved almindelig kommunikation skal begge kanalender i en kanal være klar før der kommunikeres. Styring af hvilke kanalender der indgår i kommunikation i en \code{alternation}  klares af en \code{guard}. I en \code{alternation} kan der også tilknyttes to særlige guards, \code{timeout}- og \code{SKIP-guard}. En \code{SKIP-guard} er altid klar og giver mulighed for konstruktioner som f.eks. "kommuniker hvis der er processer der ønsker at kommunikere med os, ellers fortsæt". En \code{timeout-guard} er i modsætning til \code{SKIP-guard} ikke funderet i CSP, men er lavet fra et pragmatisk synspunkt. En \code{timeout-guard} er klar efter er angivent tidspunkt og giver mulighed for konstruktioner som f.eks kommuniker med en af de ønskede processer indenfor en tidsgrænse, ellers fortsæt. 

\section{Tre implementeringer}
I artiklen \citetitle{Friborg2009}\cite{Friborg2009} præsenteres der tre forskellige implementeringer af processer i PyCSP. Hver implementation har fordele og ulemper og formålet med at have alle tre til rådighed er at give udvikleren mulighed for at vælge den implementeringer der passer bedst til en given applikation. Implementationerne deler samme API, så det er let at skifte rundt mellem dem og teste samspillet med den udviklede applikation. 

Implementationerne adskiller sig ved hvordan CSP processerne er implementeret, og derfor hvilke egenskaber der er gældende for dem. De benytter henholdsvis operativsystemets tråde(threads), bruger-tråde(greenlets), og multiprocesseringsmodulet(processes) i Python. Da \emph{Threads}-versionen benytter operativsystemets tråde vil en applikation typisk være begrænset til ca. 1000 samtidige tråde\cite[3]{Friborg2009}. Mod forventning vil denne version ikke være i stand til at udnytte flere kerner i processoren, hvilket skyldes at Pythons GIL (Global Intepreter Lock) kun tillader at en operation udføres ad gangen. Dette kan til dels omgås ved at flytte beregningstunge dele af programmet ud i eksterne moduler udviklet i et mere effektivt sprog som f.eks. C. Disse vil ikke være begrænset af GIL'en og kan derfor køres på andre kerner. 

Ønsker man udnyttelse af flere kerner kan man benytte \emph{processes}-versionen. Denne version udnytter Pythons multiprocessing der blev introduceret i Python version 2.6, som fungerer ved at der oprettes en GIL for hver proces, hvorved problemet fra \emph{thread}-versionen omgås. Ulempen er at det bliver mere ressourcekrævende og dyrt at foretage kontekstskift. 

\emph{Greenlets}-versionen går den anden vej, og implementerer CSP processer som user-level tråde i form af greenlet-modulet til Python\cite{greenlet}. Herved kan man have utroligt mange samtidige tråde, der er hurtige at skifte mellem og som er meget lidt ressourcekrævende. Dette gør denne version velegnet til applikationer der ikke har brug for at benytte flere kerner, men som består af mange CSP processer. 

\section{Introduktion af tid i de 3 implementeringer}
Vi vil foretrække en implementation af tid der er ensformig og dækker over alle tre implementeringer. Herved kan vi følge ideen i PyCSP med at benytte samme API på tværs af implementeringerne. Når vi ønsker at introducere tid i PyCSP skal vi kunne styre afviklingen af CSP processer. I  \emph{threads}- og \emph{processes}-versionerne kan vi ikke styre hvilke af de tråde der ekskvere CSP der er aktive, men kun styre hvad en tråd gør når den bliver aktiveret. For at introducere tid i disse versioner vil det kræve en væsentlig mængde kommunikation mellem trådene til styring af hvad der må afvikles hvornår. \emph{Greenlets}-versionen har derimod sin egen \sched , da den er baseret på user-level tråde og vi kan derfor styre afviklingen af CSP processerne direkte. Vi har valgt at begrænse os til kun at lave en implementation af tid i \emph{greenlets}-versionen. Som følge heraf vil alle fremtidige referencer til PyCSP være med henblik på \emph{greenlets}-versionen med mindre andet er eksplicit nævnt. Ligeledes vil vi henvise til CSP processer blot som processer. 

\section{Afvikling af processer}
I \pycsp findes der tre metoder til at afvikle processer. \code{Parallel}-kaldet benyttes til samtidig afvikling af processer ved at lægge de angivne processer på \sched en og igangsætte eksekvering af dem. \code{Sequence}-kaldet benyttes når man ønsker at afvikle processer sekventielt. Det benytter sig ikke af \sched en men gennemløber blot processerne sekventielt. \code{Spawn} er meget lig \code{parallel} med den forskel at den ikke igangsætter eksekveringen af processer. Dette skal håndteres af et foregående eller efterfølgende kald til \code{parallel}. 



\subsubsection{noter}
\fxnote*{ting som vi ikke har snakket om...skal ikke nødvendigvis med}{

buffered channels\\
retire}

