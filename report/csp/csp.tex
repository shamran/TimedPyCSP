\chapter{CSP og PyCSP}\label{chap:csp}\pdfcomment{Er det passende med en overskrift på ting der ikke er introduceret}

\inline{Vi har ikke talt om Timed CSP}
\pdfcomment{Mangler indledene meta tekts}

Vi vil i dette kapitel give en kort introduktion til CSP, mere specifikt implementationen af CSP i Python kaldet \pycsp. Vi vil ikke gennemgå hverken CSP eller \pycsp i deres helhed, men kun gennemgå de dele af \pycsp, der er relevante i fht. introduktionen af vores tidsmodeller. 

CSP er et sprog til at beskrive uafhængige processer, der udelukkende udveksler information ved at sende og modtage beskeder over eksplicitte kanaler. Det blev introduceret af \citeauthor{hoare-csp} i \citetitle{hoare-csp}\cite{hoare-csp} og ligger til grund for adskillige praktiske implementeringer i et udvalg af programmeringssprog heriblandt Occam, Java, C++ og Python\cite{May1983, jcsp, Brown2007, pycsp}. En implementeringen i Python hedder \pycsp og er udviklet i et samarbejde mellem Tromsø Universitet og Københavns Universitet med henblik på at kombinere  Pythons muligheder  for effektivt og hurtigt at udvikle programmer med CSPs evne til at udtrykke samtidighed\cite{pycsp}. 

\section{Kommunikation mellem processer}
\pdfcomment{Er forholdet mellem implementeringer processer og kanaler kendt viden ? Er definitionen af disse begreber kendt viden?}
I CSP sker al kommunikation over kanaler. En kanal har to eller flere kanalender, som processer kan kobles til. En proces vælger på forhånd, om den vil læse eller skrive til en kanal, ved at koble sig på den respektive kanalende. De nævnte implementeringer har forskellige typer kanaler, der adskiller sig ved,  hvordan de forbindes til andre processer. Generelt findes der fire typer kanaler: one-to-one, any-to-one, one-to-any og any-to-any. Forskellen ligger i hvem og hvor mange, der kan læse og skrive til en kanal. Det er klart, at any-to-any kanalen er den mest generelle og har funktionalitet som de andre. Dette er udnyttet i bl.a. PyCSP hvor det er den eneste kanaltype der er til rådighed. Fælles for de fire kanaltyper er, at processen ikke kender til kanalen og hvilken proces, der er i den anden ende af kanalen. I stedet kender processen kun til en  kanalende, som  den enten kan skrive til eller læse fra. Hvis to processer både skal kunne læse fra og skrive til hinanden, skal der bruges to kanaler med tilhørende kanalender. 

Kommunikation mellem to processer i CSP kan kun ske, når begge processer er klar til at kommunikere. Hvis den ene proces er klar før den anden, er den nødt til at vente. Når de begge er klar kan de kommunikere og så fortsætte.

En \code{alternation} er en struktur til at foretage valg omkring kommunikation. En \code{alternation} kan indeholde et vilkårligt antal kanalender, men der kommunikeres kun på en af dem. Ligesom ved almindelig kommunikation i CSP skal begge kanalender i en kanal være klar, før der kommunikeres. Det er en  \code{guard} der styrer, hvilke kanalender, der indgår i kommunikation i en \code{alternation}. Der kan tilknyttes to særlige guards, \code{SKIP-} og \code{timeout-guard}. En \code{SKIP-guard} er altid klar og giver mulighed for konstruktioner som f.eks. "kommuniker, hvis der er processer, der ønsker at kommunikere med os, ellers fortsæt". En \code{timeout-guard} er i modsætning til en \code{SKIP-guard} ikke funderet i CSP, men er lavet udfra et pragmatisk synspunkt. Den er klar efter et angivent tidspunkt og giver mulighed for konstruktioner som f.eks ''kommuniker med en af de ønskede processer indenfor en tidsgrænse, ellers fortsæt''. 

\section{Tre implementeringer}
I artiklen \citetitle{Friborg2009}\cite{Friborg2009} præsenteres tre forskellige implementeringer af processer i PyCSP. Hver implementation har fordele og ulemper, og formålet med at have tre til rådighed er at give udvikleren mulighed for at vælge den implementering der passer bedst til en given applikation. Implementeringerne deler samme API, så det er let at skifte rundt mellem dem og teste samspillet med den udviklede applikation. 

De tre versioner adskiller sig kun ved den måde \csp-processerne internt er implementeret, og derfor også ved hvilke egenskaber, der er gældende for dem. De benytter henholdsvis operativsystemets tråde (threads), multiprocesseringsmodulet (processes) og brugertråde (greenlet) i Python. En applikation i \code{threads}-versionen vil typisk være begrænset til ca. 1000 samtidige tråde\cite[3]{Friborg2009}. Vi forventer umidelbart at denne version er i stand til at udnytte flere kerner i processoren. Dette er dog ikke tilfældet, fordi Pythons Global Intepreter Lock (GIL) kun tillader, at en operation udføres ad gangen. Dette kan til dels omgås ved at flytte beregningstunge dele af programmet ud i eksterne moduler udviklet i et mere effektivt sprog som f.eks. C. Disse vil ikke være begrænset af GIL'en og kan derfor køres på andre kerner. 

Ønsker man udnyttelse af flere kerner, kan man i stedet benytte \code{processes}-versionen. Denne version udnytter Pythons multiprocessing, der blev introduceret i Python version 2.6, og fungerer ved, at der oprettes en GIL for hver proces, hvorved problemet fra \code{thread}-versionen omgås. Ulempen er, at det bliver mere ressourcekrævende og dyrt at foretage kontekstskift.
\pdfcomment{De informationer ang. de tre implementeringer der kommer i hhv. afsnit 1.2 og 1.3 ..
Jeg forstår ikke hvorfor der er delt op i to afsnit på denne måde. Jeg synes I skriver om type A,B og C for så at lave et nyt afsnit og for så igen at skrive om de te typer.
Hvorfor skriver iikke dele hele om A så det hele om B ..
Hvis afsnit 1.3 bygger på afsnit 1.2 synes jeg ikke det fremgår klart}
Den sidste mulighed er \code{Greenlets}-versionen, der går den anden vej og implementerer \csp-processer som user-level-tråde i form af greenlet-modulet til Python\cite{greenlet}. Herved kan man have utroligt mange samtidige tråde, der er hurtige at skifte mellem, og som er meget lidt ressourcekrævende. Dette gør denne version velegnet til applikationer, der ikke har brug for at benytte flere kerner, men som består af mange \csp-processer. 

\section{Introduktion af tid i de tre implementeringer}
Vi vil foretrække en implementering af tid, der kan dækker over alle tre versioner. Herved kan vi følge ideen i \pycsp med at benytte samme API på tværs af implementeringerne. 

Når vi ønsker at introducere tid i \pycsp, heriblandt tidsmæssige begrænsninger, skal vi kunne styre afviklingen af \csp-processer. I  \code{threads}- og \code{processes}-versionerne kan vi ikke styre, hvilke af de tråde, der eksekverer \csp, der er aktive, men kun styre hvad en tråd gør, når den bliver aktiveret. Dette skyldes, at kontrollen ligger i operativsystemets skemaplanlægger, som vi som udgangspunkt ikke kan ændre i. At introducere tid i disse versioner kræver en væsentlig mængde kommunikation mellem trådene til styring af, hvad der må afvikles hvornår. \code{Greenlets}-versionen har derimod sin egen \sched , da den er baseret på user-level tråde, og vi kan derfor styre afviklingen af CSP-processerne direkte. Vi har derfor valgt at begrænse os til kun at lave en implementering af tid i \code{greenlets}-versionen. Som følge heraf vil alle fremtidige referencer til PyCSP være med henblik på \code{greenlets}-versionen med mindre andet er nævnt. Ligeledes vil \csp-processer  blot blive  kaldt  processer. 

\section{Afvikling af processer}
I \pycsp findes der tre metoder til at afvikle processer. \code{Parallel}-kaldet benyttes til samtidig afvikling af processer ved at lægge de angivne processer på \sched en og igangsætte eksekvering af dem. \code{Sequence}-kaldet benyttes, når man ønsker at afvikle processer sekventielt. Det bruger ikke \sched en, men gennemløber blot processerne sekventielt. \code{Spawn} er meget lig \code{parallel} med den forskel, at den ikke igangsætter eksekveringen af processer. Dette skal håndteres af et foregående eller efterfølgende kald til \code{parallel}. \fxnote{Og hvad så ...}

\inline{vi kan evt skrive om buffered channels og retire i nye afsnit}
 \pdfcomment{Hvad er I nået fremt il i dette kapitel?}
