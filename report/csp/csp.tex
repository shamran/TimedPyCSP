\chapter{CSP og PyCSP}
CSP er et sprog til at beskrive uafhængige processer, der udelukkende udveksler information ved at sende og modtage beskeder over eksplicitte kanaler mellem processerne. Det blev introduceret af \citeauthor{hoare-csp} i \citetitle{hoare-csp}\cite{hoare-csp} og ligger til grund for adskillige praktiske implementationer i et udvalg af programmeringssprog, heriblandt Occam, Java, C++ og Python\cite{May1983, jcsp, Brown2007, pycsp}. I Python hedder udviddelsen PyCSP, og er udviklet i et samarbejde mellem mellem Tromsø og Københavns Universitet, med henblik på at kombinere fordelene fra Python og CSP. 

\section{Kommunikation mellem processer}
Kommunikation mellem to processer i CSP kan kun ske når begge processer er klar til at kommunikere. Hvis den ene proces er klar før den anden er den nødt til at vente på at begge er klar. Herefter kan de kommunikere og så fortsætte. Selve kommunikationen foregår over kanaler. De nævnte implementationer har forskellige typer kanaler, set med henblik hvordan de forbindes til andre processer. Generelt findes der fire 4 typer af kanaler: one-to-one, any-to-one, one-to-any og any-to-any. Forskellen ligger i hvem og hvor mange der kan læse og skrive til en kanal. Det er klart at any-to-any kanalen er den mest generelle og har funktionalitet som de andre. Dette er udnyttet i bl.a. PyCSP hvor det er den eneste kanaltype der er til rådighed. Fælles for dem er at det skal specificeres om en proces skal kunne skrive eller læse fra en kanal\fxnote[inline, nomargin]{fact check på dette}. Hvis to processer skal kunne både læse fra, og skrive til hinanden, skal de have to kanaler for at opnå det. 

En \code{alternation} er en struktur til at foretage valg omkring kommunikation. En \code{alternation} kan indeholde et vilkårligt antal kanalender, samt eventuelt en \code{guard}. Når en \code{alternation} udføres foretages der således et valg mellem de kanaler der er klar eller \code{guarden}. En guard kan enten være en \code{timeout}- eller \code{SKIP-guard}. En \code{timeout-guard} er klar efter en angivent tidspunkt og en \code{SKIP-guard} er altid klar. Dette giver mulighed for konstruktioner som f.eks. "kommuniker hvis der er processer der ønsker at kommunikere med os, ellers fortsæt". 

\section{Afvikling af processer}
I \pycsp findes der tre metoder til at afvikle processer. \code{Parallel}-kaldet benyttes til samtidig afvikling af processer, \code{sequence}-kaldet benyttes når man ønsker at afvikle processer sekventielt og \code{spawn} bruges til planlægge kørsel af processer ved at lægge dem på \sched en. 
\fxnote[inline, nomargin]{Hvad skal vi mere sige om dem?}


\section{Tre implementeringer}
I artiklen \citetitle{Friborg2009}\cite{Friborg2009} præsenteres der tre forskellige implementationer af processer i PyCSP. Hver implementation har fordele og ulemper og formålet med at have alle tre til rådighed er at give udvikleren mulighed for at vælge den implementation der passer bedst til en given applikation. Implementationerne deler samme API, så det er let at skifte rundt mellem dem og teste samspillet med den udviklede applikation. 

Implementationerne adskiller sig ved hvordan CSP processerne er implementeret, og derfor hvilke egenskaber der er gældende for dem. De benytter henholdsvis operativsystemets tråde(threads), bruger-tråde(greenlets), og multiprocesseringsmodulet(processes) i Python. Da \emph{Threads}-versionen benytter operativsystemets tråde vil en applikation typisk være begrænset til ca. 1000 samtidige tråde\cite[3]{Friborg2009}. Mod forventning vil denne version ikke være i stand til at udnytte flere kerner i processoren, hvilket skyldes at Pythons GIL (Global Intepreter Lock) kun tillader at en operation udføres ad gangen. 

Ønsker man udnyttelse af flere kerner kan man benytte \emph{processes}-versionen. Denne version udnytter Pythons multiprocessing der blev introduceret i Python version 2.6, som fungerer ved at der oprettes en GIL for hver proces, hvorved problemet fra \emph{thread}-versionen omgås. Ulempen er at det bliver mere ressourcekrævende og dyrt at foretage kontekstskift. 

\emph{Greenlets}-versionen går den anden vej, og implementerer CSP processer som user-level tråde. Herved kan man have utroligt mange samtidige tråde, der er hurtige at skifte mellem og som er meget lidt ressourcekrævende. 

\section{Introduktion af tid i de 3 implementeringer}
Vi vil foretrække en implementation af tid der er ensformig og dækker over alle tre implementeringer. Herved kan vi følge ideen i PyCSP med at benytte samme API på tværs af implementeringerne. Når vi ønsker at introducere tid i PyCSP skal vi kunne styre rækkefølgen for afvikling af CSP processer. I  \emph{threads}- og \emph{processes}-versionerne kan vi ikke styre hvilke CSP tråde der er aktive, men kun styre hvad en tråd gør når den bliver aktiveret. For at introducere tid i disse versioner vil det kræve en væsentlig mængde kommunikation mellem trådene til styring af hvad der må afvikles hvornår. \emph{Greenlets}-versionen har derimod sin egen \sched , da den er baseret på user-level tråde og vi kan derfor styre afviklingen af CSP processerne direkte. Vi har derfor valgt at begrænse os til kun at lave en implementation af tid i \emph{greenlets}-versionen. 

\subsubsection{noter}
\fxnote*{ting som vi ikke har snakket om...skal ikke nødvendigvis med}{
buffered channels\\
retire}





