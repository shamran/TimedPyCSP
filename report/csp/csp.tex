\chapter{CSP og PyCSP}\label{sec:csp}\pdfcomment{Er det passende med en overskrift på ting der ikke er introduceret}
\inline{}
\inline{Vi har ikke talt om Timed CSP}
\pdfcomment{Mangler indledene meta tekts}
CSP er et sprog til at beskrive uafhængige processer, der udelukkende udveksler information ved at sende og modtage beskeder over eksplicitte kanaler mellem processerne. Det blev introduceret af \citeauthor{hoare-csp} i \citetitle{hoare-csp}\cite{hoare-csp} og ligger til grund for adskillige praktiske implementeriner i et udvalg af programmeringssprog heriblandt Occam, Java, C++ og Python\cite{May1983, jcsp, Brown2007, pycsp}. I Python hedder implementeringen \pycsp, og er udviklet i et samarbejde mellem mellem Tromsø Universitet og Københavns Universitet med henblik på at kombinere \kv{mulighederne i Python for effektivt og hurtigt at udvikle programmer med CSPs evne til at udtrykke samtidighed\cite{pycsp}.} 

\section{Kommunikation mellem processer}
\pdfcomment{Er forholdet mellem implementeringer processer og kanaler kendt viden ? Er definitionen af disse begreber kendt viden?}Alt kommunikationen foregår over kanaler. De nævnte implementeringer har forskellige typer kanaler, der adskiller sig ved  hvordan de forbindes til andre processer. Generelt findes der fire typer af kanaler: one-to-one, any-to-one, one-to-any og any-to-any. Forskellen ligger i hvem og hvor mange, der kan læse og skrive til en kanal. Det er klart at any-to-any kanalen er den mest generelle, og har funktionalitet som de andre. Dette er udnyttet i bl.a. PyCSP hvor det er den eneste kanaltype der er til rådighed. Fælles for de fire kanaltyper er, at processen ikke kender til kanalen og hvilken proces, der er i den anden ende af kanalen. Istedet kender processen kun til en  kanalende, som  den enten kan skrive til eller læse fra. Hvis to processer både skal kunne læse fra, og skrive til hinanden, skal der bruges to kanaler med tilhørende kanalender. 

Kommunikation mellem to processer i CSP kan kun ske, når begge processer er klar til at kommunikere. Hvis den ene proces er klar før den anden, er den nødt til at vente. Når de begge er klar kan de kommunikere og så fortsætte.

En \code{alternation} er en struktur til at foretage valg omkring kommunikation. En \code{alternation} kan indeholde et vilkårligt antal kanalender, men der kommunikeres kun på en af dem. Ligesom ved almindelig kommunikation skal begge kanalender i en kanal være klar, før der kommunikeres. Styring af hvilke kanalender, der indgår i kommunikation i en \code{alternation}  klares af en \code{guard}. I en \code{alternation} kan der tilknyttes to særlige guards, \code{timeout}- og \code{SKIP-guard}. En \code{SKIP-guard} er altid klar og giver mulighed for konstruktioner som f.eks. "kommuniker, hvis der er processer, der ønsker at kommunikere med os, ellers fortsæt". En \code{timeout-guard} er i modsætning til \code{SKIP-guard} ikke funderet i CSP, men er lavet fra et pragmatisk synspunkt. En \code{timeout-guard} er klar efter et angivent tidspunkt og giver mulighed for konstruktioner som f.eks ''kommuniker med en af de ønskede processer indenfor en tidsgrænse, ellers fortsæt''. 

\section{Tre implementeringer}
I artiklen \citetitle{Friborg2009}\cite{Friborg2009} præsenteres tre forskellige implementeringer af processer i PyCSP. Hver implementation har fordele, og ulemper og \fxnote*{Forstår Dorte ikke, forstår Dataloger}{formålet med at have alle tre til rådighed er at give udvikleren mulighed for at vælge den implementeringer der passer bedst til en given applikation}. Implementeringerne deler samme API, så det er let at skifte rundt mellem dem og teste samspillet med den udviklede applikation. 

Implementationerne adskiller sig kun ved den måde \csp-processerne internt er implementeret\pdfcomment{dårligt formuleret}, og derfor også ved hvilke egenskaber, der er gældende for dem. De benytter henholdsvis operativsystemets tråde(threads), multiprocesseringsmodulet(processes) og bruger-tråde(greenlet) i Python. En applikation i \code{threads}-versionen vil typisk være begrænset til ca. 1000 samtidige tråde, da den benytter operativsystemets tråde\cite[3]{Friborg2009}. Med operativsystemtråde burde denne version  være i stand til at udnytte flere kerner i processoren, men mod forventning kan den det ikke, hvilket skyldes at Pythons Global Intepreter Lock (GIL) kun tillader en operation udføres ad gangen. Dette kan til dels omgås ved at flytte beregningstunge dele af programmet ud i eksterne moduler udviklet i et mere effektivt sprog som f.eks. C. Disse vil ikke være begrænset af GIL'en og kan derfor køres på andre kerner. 

Ønsker man udnyttelse af flere kerner, kan man benytte \code{processes}-versionen. Denne version udnytter Pythons multiprocessing, der blev introduceret i Python version 2.6, og fungerer ved at der oprettes en GIL for hver proces, hvorved problemet fra \code{thread}-versionen omgås. Ulempen er, at det bliver mere ressourcekrævende og dyrt at foretage kontekstskift. 

\code{Greenlets}-versionen går den anden vej og implementerer \csp-processer som user-level-tråde i form af greenlet-modulet til Python\cite{greenlet}. Herved kan man have utroligt mange samtidige tråde, der er hurtige at skifte mellem, og som er meget lidt ressourcekrævende. Dette gør denne version velegnet til applikationer, der ikke har brug for at benytte flere kerner, men som består af mange \csp-processer. 

\section{Introduktion af tid i de tre implementeringer}
Vi vil foretrække en implementation af tid der er ensformig og dækker over alle tre implementeringer. Herved kan vi følge ideen i PyCSP med at benytte samme API på tværs af implementeringerne. Når vi ønsker at introducere tid i PyCSP skal vi kunne styre afviklingen af CSP processer. I  \code{threads}- og \code{processes}-versionerne kan vi ikke styre hvilke af de tråde der ekskvere CSP der er aktive, men kun styre hvad en tråd gør når den bliver aktiveret. For at introducere tid i disse versioner vil det kræve en væsentlig mængde kommunikation mellem trådene til styring af hvad der må afvikles hvornår. \code{Greenlets}-versionen har derimod sin egen \sched , da den er baseret på user-level tråde og vi kan derfor styre afviklingen af CSP processerne direkte. Vi har valgt at begrænse os til kun at lave en implementation af tid i \code{greenlets}-versionen. Som følge heraf vil alle fremtidige referencer til PyCSP være med henblik på \code{greenlets}-versionen med mindre andet er eksplicit nævnt. Ligeledes vil vi henvise til CSP processer blot som processer. 

\section{Afvikling af processer}
I \pycsp findes der tre metoder til at afvikle processer. \code{Parallel}-kaldet benyttes til samtidig afvikling af processer ved at lægge de angivne processer på \sched en og igangsætte eksekvering af dem. \code{Sequence}-kaldet benyttes når man ønsker at afvikle processer sekventielt. Det benytter sig ikke af \sched en men gennemløber blot processerne sekventielt. \code{Spawn} er meget lig \code{parallel} med den forskel at den ikke igangsætter eksekveringen af processer. Dette skal håndteres af et foregående eller efterfølgende kald til \code{parallel}. 

\inline{vi kan evt skrive om buffered channels og retire i nye afsnit}

