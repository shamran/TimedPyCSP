\section{Konklusion}
Vi har nu gennemgået tidsmodellen \des og redegjort for dens anvendelsesområder. Vi er kommet frem til at en \des grundlæggende skal have tre ting til rådighed; en repræsentation af tid, en liste over begivenheder og muligheden for at opsamle statistisk data. I \pycsp er begivenheder repræsenteret ved processer og vi har introduceret en repræsentation af tid i form af en intern variabel der vedligeholdes i skemaplanlæggeren. Vores opsamling af statistisk data er i i stor grad inspireret og annekteret fra SimPy i form af dens \code{Monitor}-klasse. 

De primære problemstillinger omkring \des er håndtering af hvordan vi sikrer at alle processer til et givet tidsskridt bliver udført tidsmæssigt korrekt, og hvordan vi håndterer allerede eksisterende tidselementer i \pycsp. Vi har ændret \code{timers}-listen i skemaplanlæggeren til at være en min-hob indeholdende processer, sorteret efter hvilket tidsskridt de skal udføres i. Herved kan vi aktivere det mindste element i hoben indtil vi ser en ændring i tidsskridtet. I \pycsp benyttes \code{timers}-listen kun i forbindelse med \code{alternations} og vil derfor sjældent indeholde mange elementer. Vi ændrer brugen af \code{timers} så den indeholder alle processer der er planlagt, undtaget dem der venter på kommunikation. Datastrukturen vil derfor indeholde betydeligt flere elementer hvilket er grunden til at vi har vagt at benytte en hob i stedet for. 
Det eneste eksisterende tidselement i \pycsp er timeout-guards i \code{alternations} og skal altså konverteres fra pseudo-realtid til diskret tid. Funktionen bruges såfremt kommnikation indenfor den givne tidsramme ikke har været mulig. I \des ændrer tilstanden for systemet sig i tidsskridtene og kommunikation kan derfor blive mulig i løbet af et tidsskridt. Problemet går derved på at få udført al mulig kommunikation i et tidskridt, selv om det eventuelt først bliver muligt i løbet af det indeværende tidsskridt. Løsningen er at benytte den metode der hedder edge-triggering, hvor vi opdeler processerne i to grupper, henholdsvis wake-first og wake-last. Wake-first gruppen er alle processer der er har planlagt en begivehed til det aktuelle tidsskridt og wake-last indeholder processer der venter på en timeout. 

Vi har lavet to eksempler der begge er implementeret både med og uden brug af vores \des løsning. Vi har klarlagt at det, uden vores \des løsning, er nødvendigt at benytte barrierer til at repræsentere tid, og at denne metode bryder med det grundlæggende princip i CSP om ikke at have delte datastrukturer. Yderligere viser vi at vores implementering imødekommer dette problem og tilbyder en repræsentation af tid så udvikleren ikke har brug for delte datastrukturer. derudover illustreres det at der bruges væsentligt mindre kode på at håndtere tiden når det er implementeret direkte i \pycsp, hvilket generelt resulterer i mere overskuelig kode, da den derved primært udtrykker det konkrete problem der skal løses. De to eksempler er af grundlæggende forskellig karakter, og vi kan se at fordelene ved vores \des implementering er væsentlig større i bankeksemplet end i Wa-Tor-eksemplet. Grunden til dette er, at en simulering af en bank generelt egner sig godt til at illustrere \des, hvor Wa-Tor er en kontinuerlig simulering og kan derfor ikke drage fuld nytte af egenskaberne ved \des. 

Vores løsning er centreret omkring de ovennævnte ændringer i skemaplanlæggeren, samt en tilføjelse af to funktioner som udviklere kan benytte. Disse funktioner er \code{now} og \code{wait}, der bruges til henholdsvis at få den nuværende tid og vente med yderligere udførsel indtil den angivne tid. Vi mener selv at dette er en elegant løsning som er let at anvende og at vores udvidelse kan bruges i praksis ved konstruktion af simuleringer i diskret tid. 

