
\section{Design og implementering}
\inline{Beskrivelse af design med udgangspunkt i eksemplet}
\begin{shaded}
Formålet med introduktionen er to ting. Dels ønsker vi at introducere diskret tid som et alternativ til barrierer. Dels ønsker vi med diskret tid at åbne for mulighederne for at kunne foretage simuleringer, hvor man bruger \csp som model for systemet. Med disse ændringer er håbet at vi opnår en model der ligger tætter på intentionen bag \csp og så man kan udfase brugen af barrierer, samt med den underliggende parallelitet i \csp kan udnyttes til at øge hastigheden af de simulere modeller, hvis de er begrænset af beregningskapaciteten.\inline{RS:hvordan er dette relateret til design/implementation? - SB: Det er indledende motivation.}

I \des  skal tiden styres centralt og processerne skal alle have mulighed for at vide hvad klokken er når den kører. Tiden skal altid være den samme på tværs af alle processer og derfor skal der være en central kontrol med processerne, så man kan styre hvilke processer der køre på forskellige tidspunkter. Dette er let at styre ved hjælp af PyCSP's \sched ~i \code{greenlets}"-versionen, hvor vi har fuld kontrol over afviklingen af individuelle processer. 
\end{shaded}

\subsection{Kodestruktur}  
Efter at have valgt at udvide \emph{greenlet}-versionen skal vi vælge hvordan vi ønsker at videreudvikle koden. Vi forventer at genbruge store dele af koden fra \emph{greenlet}-versionen, og kun foretage udvidelser på enkelte afgrænsede områder. Desuden ønsker vi at isolere vores ændringer fra den originale \emph{greenlet}-versionen. Med denne isolation forventer vi at hvis/når der sker tilrettelser af \emph{greenlet}versionen af \pycsp vil man ikke skulle foretage de samme tilrettelser i \des versionen. 
Isolationen mellem \des- og \emph{greenlet}versionen ønsker vi at få ved nedarvning, men således at det fra en brugers synsvinkel ser ud til at \des versionen er en selvstændig version.

Hvert af de tre versioner har sin egen mappe i \pycsp og i hver af disse findes en tilhørende \code{\_\_init\_\_.py} fil, der fungerer som et manifest for den givne version. Vi opretter vores egen version kaldet \emph{simulation}, og opretter en tilhørende mappe på samme niveau som de andre versioner og med sin egen manifestfil. Manifestfilen kan nu bruges til at udvælge de funktioner der skal tages direkte fra \emph{greenlet}-versionen og hvilke funktioner der skal udvides og som derfor vil ligge i den nye mappe.
\begin{lstlisting}[float=hbtp,label=fig:init,caption=Uddrag af \code{\_\_init\_\_.py} for simulationsversionen.]
from guard import Timeout, Skip
from pycsp.greenlets.alternation import choice
from alternation import Alternation
from pycsp.greenlets.channel import ChannelPoisonException, ChannelRetireException
\end{lstlisting}

I \cref{fig:init} kan man se at funktionerne \code{choice}, \\\code{ChannelPoisonException} og \code{ChannelRetireException} alle bliver hentet fra \emph{greenlet}-versionen, mens at funktionerne \code{Timeout, Skip} og \code{Alternation} bliver importeret fra samme mappe, og derfor er en modificeret version. For slutbrugeren  vil dette dog være transparent, og vil blot se \emph{simulation}-versionen som en selvstændig version på lige fod med de andre tre versioner.

\subsection{Scheduler-klassen}
Med valget af \emph{greenlet}-versionen som grundversion og med henblik på at hovedparten af vores ændringer vil være i \sched en, vil vi kort gennemgå klassen \code{Scheduler}.

\begin{lstlisting}[firstnumber=132,stepnumber=5,numbers=left, float, label=fig:scheduling, caption=Uddrag af Scheduler.py i \emph{greenlets}versionen.]
    def getInstance(cls, *args, **kargs):
        '''Static method to have a reference to **THE UNIQUE** instance'''
        if cls.__instance is None:
            # (Some exception may be thrown...)
            # Initialize **the unique** instance
            cls.__instance = object.__new__(cls)

            # Initialize members for scheduler
            cls.__instance.new = []
            cls.__instance.next = []
            cls.__instance.current = None
            cls.__instance.greenlet = greenlet.getcurrent()

            # Timer specific  value = (activation time, process)
            # On update we do a sort based on the activation time
            cls.__instance.timers = []

            # Io specific
            cls.__instance.cond = threading.Condition()
            cls.__instance.blocking = 0
\end{lstlisting}

 I \cref{fig:scheduling} ses et uddrag af initialiseringskoden, der er interessant fordi det er her alle de interne datastrukturer oprettes. Man kan se der findes tre lister af processer som \sched en har til rådighed til at varetage processkifte. 
 \begin{list}
 \tightlist 
 \item \code{new}: Initieres på linje 140, og består af processer som lige er blevet planlagt for første gang. Nye processer kan ankomme til listen \code{new} via funktionerne \code{Parallel, Sequence} og \code{Spawn}.
 \item \code{next}: Initieres på linje 141, og indeholder de processer der er klar til at blive kørt, og som har været kørt på et tidligere tidspunkt. \fxnote*{omskriv}{Et eksempel kunne være en proces der har stoppet sin kørsel for at vente på kommunikation, hvor processen vil blive placeret i denne liste når kommunikationen er overstået, da den nu er klar til at fortsætte.} 
 \item \code{timers}: Initieres på linje 147, og indeholder de processer der har tilknyttet en timeout. De skal først planlægges på et senere tidspunkt og venter dermed blot. Hvert element i listen består både af processen samt et tidsstempel for hvornår processen skal genaktiveres. 
 \item \code{blocking}: Initieres på linje 151, og er en variabel. Processer der venter på IO operationer, er ikke klar til at blive planlagt, men heller ikke afsluttet. \Sched en kan derfor ikke planlægge dem, men holder styr på antallet af ventende processer vha. denne variabel. Dette bruges bla. for at kunne afgøre om \sched en har planlagt alle processer.
\end{list}

Når \sched en er startet, gennemløber den alle tre lister gentagne gange, indtil de alle er tomme, og der ikke er nogle processer der er blokeret. Dette betyder at der ikke længere kan komme nye processer til der ønsker at blive lagt på \sched en, og den kan dermed afslutte.
\begin{shaded}
For at markere at vi ikke kun skal foretage en planlægning
af processerne, men foretage en simulering, har vi lavet en
\code{Simulation} klasse der arver fra \code{Scheduler}. Alle ændringer
vi skal foretage for at gå fra en almindelig \sched ~til en simulerings
\sched, vil således indkapsles i denne klasse, mens alt hvad de to
klasser har til fælles vil være isoleret i \emph{greenlets} versionen af
\code{Scheduler} klassen. Dette har yderligere den fordel at man tydeligt kan se
at alle klasserne i \emph{simulation}versionen arver en simulerings \sched ~og
ikke \code{Scheduler} fra greenletsversionen.
\end{shaded}
%\fxnote{dårlig overskrift}{\subsection{Repræsentation af tid}} Vi
%vil i dette afsnit gå i dybden med listen \code{timers} der findes i
%klassen \code{Scheduler}, samt se hvordan den kan inkorporeres i vores
%design.

\subsection{Tid} \label{sec:tid}
\CRef{Timeout} viser et eksempel på en \code{alternation} hvor processen kun er villig
til at læse fra kanalenden \code{Cin} i $0.5$ sekunder. Hvis ikke der
er modtaget en besked indenfor 0.5 sekunder, accepteres timeoutguarden
og processen fortsætter sin kørsel uden at have læst fra kanalen.

\begin{lstlisting}[%float=hbtp, 
label=Timeout,caption=Timeout i Alternation (fra dokumentationen til PyCSP)]
Alternation([{Timeout(seconds=0.5):None}, 
             {Cin:None}]).select()
\end{lstlisting}

Tid er dermed blevet introduceret i \pycsp, for i denne specifikke situation at at have
mulighed for at tilknytte timeout til en \code{alternation}. Vi ønsker
at videreudvikle denne struktur til at håndtere tid generelt for alle
processer, men ændre tiden så den fungerer med diskret tid, modsat den eksisterende
løsning hvor tiden er realtid.

For at konvertere \emph{greenlets}-versionen der bruger  til realtid til en simuleringsversion der bruger diskrettid, skal vi ændre de steder i koden som allerede bruger tid. Det eneste sted tid har indflydelse er i listen \code{timers}. Vi kan dermed nøjes med at ændre de steder i \sched en som involverer \code{timers}. Det første sted hvor \code{timers} bruges er i udvælgelsen af hvilken proces der skal køres(\cref{fig:green:timer}). \fxnote*{RS: relevans?}{Her sammenlignes på linje 204 den første tidsværdi i \code{timers}, med det nuværende tidspunkt. Hvis det nuværende tidspunkt er større end værdien i timers udvælges denne proces til at køre næste gang og fjernes fra listen.}

Da tiden står tiden stille mens en proces kører i den diskrete tid og processen kan fortsætte så længe den ønsker kræver det et aktivt valg før tiden stiger. Vi kan derfor tilføje en yderligere begrænsning i forhold til \emph{greenlets}-versionen: \fxnote*{Hvorfor er det relevant - hvad kan vi bruge det til/udnytte?}{For \emph{simulerings}-versionen skal tiden være præcist det der er angivet i \code{timers}, før processen skal aktiveres, og ikke kun større, som angivet i \emph{greenlets}versionen.} \CRef{fig:sim:timer} viser udvælgelsen af en proces fra \code{timers} i \emph{simulerings}-versionen.

\begin{figure}[hbtp]
\begin{minipage}[c]{\linewidth}
\begin{lstlisting}[firstnumber=204, label=fig:green:timer, caption=Udvælgelse af proces fra listen timers (fra scheduling.py)]
if self.timers and self.timers[0][0] < time.time():
  _,self.current = self.timers.pop(0)
  self.current.greenlet.switch()
\end{lstlisting}
\end{minipage}
\begin{minipage}[c]{\linewidth}
\begin{lstlisting}[firstnumber=124, label=fig:sim:timer, caption=Udvælgelse af proces fra listen timers (fra simulation.py)]
if self.timers and self.timers[0][0] <= Now():
  assert self.timers[0][0] == Now()
  _,self.current = heapq.heappop(self.timers)
  self.current.greenlet.switch()
\end{lstlisting}
\end{minipage}
\end{figure}

\subsection{Funktionen Wait}\label{sec:Wait}
I \des planlægger forskellige instanser hvilke begivenheder der skal foregå ud i fremtiden.  Dette er ikke en farbar vej at gå til udvikling af et simuleringsmiljø som en computer kan evaluerer. Det skyldes at det ikke er praktisk muligt for en computer at kunne håndtere alle de typer begivenheder der skal kunne planlægges. Et alternativ er at ikke at planlægge begivenheder, men istedet at lade instansen vente og så behandle begivenheden med det samme. Dermed skal man ikke kunne planlægge begivenhedder men holde instanser tilbage. 

\begin{lstlisting}[firstnumber=11 , stepnumber=2, numbers=left,float=hbtp, label=fig:simpy:yield, caption= Et yield i \simpy (Taget fra Bank05.py i eksemplet fra \simpy)] 
def visit(self,timeInBank): 
  print now(), self.name," Here I am" 
  yield hold,self,timeInBank print now()
  self.name," I must leave" 
\end{lstlisting}
I programmeringssproget \simpy benytter man også metoden til at lade en proces vente. Dette gør de ved at
foretage kaldet \code{yield}, som sørger for at processen ikke
fortsætter før et defineret tidsrum er gået. \CRef{fig:simpy:yield} viser hvordan en kunde er ankommet til banken. Kunden printer tiden, foretager et \code{yield}, printer tiden igen og afslutter.  Når processen har kaldt \code{yield}, er tiden steget med værdien af \code{timeInBank}. Grunden til at de kan bruge \code{yield}, der er indbygget i Python og at dette kaldeafgiver kontrol over processen i et tidsrum  knytter sig til implementeringen af \simpy og der bruger  \code{corutine} som underliggende teknologi. 

 Vi ønsker i \pycsp at have en lignende mulighed for at lade en proces vente. Denne funktionalitet er heldigvis allerede delvist introduceret via \code{timeout} i \emph{greenlets}-versionen af \pycsp, og vi kan derfor bygge videre på denne funktionalitet med funktionen \code{Wait}, der fungerer som timeout, men som kan kaldes af processerne
på et vilkårligt tidspunkt.
\begin{lstlisting}[firstnumber=20,float=hbtp, label=fig:wait, caption=Wait i simuleringsversionen.] 
def Wait(seconds):
  Simulation().timer_wait(Simulation().current, seconds)
  t = Now()+seconds
  while Now()<t:
    p = Simulation().getNext() 
    p.greenlet.switch()
\end{lstlisting}

Funktionen \code{Wait} står for at kalde den interne funktion lavet til timeouts kaldet time\_wait, samt sørge for at først at returnere når tiden er steget til det påkrævede. \code{Wait} er essentielt det eneste værktøj der skal til for at vente/planlægge begivenheder ud i fremtiden, og vi har på nuværenede tidspunkt en simpel \des der kører i realtid. 

\subsection{Fra reel tid til diskret tid.}\label{sec:discrete}
 I \pycsp benyttes modulet \fxnote{Motiver: hvorfor snakker vi om dette / er det relevant}
\code{time} til at håndtere tiden i timeouts. Fra en brugers synsvinkel
repræsenteres tiden internt som realtid der er kontinuerlig. Med computere findes realtid ikke, men  er internt repræsenteret
som diskret. Med  \des vil der derfor ikke ske en konvertering fra realtid til  diskrettid. 

\Des er derimod en konvertering fra en diskrettid, med et fast tidsskridt til at tiden stiger med en variable tidsskridt. 
Da man i \code{time} modulet har et fast tidsskridt og
realtiden også er inddelt i faste størrelser
som eks. sekunder, kan man med \code{time} modulet måle tidsintervaller der
korrespondere med realtiden. I \des findes der ikke en
sammenhæng til  realtiden, da tiden blot et tal der starter som 0, og stiger
i abitrære tidskridt. Når tiden i \des på denne måde er afkoblet
en relation til realtid, kan man heller ikke snakke om at et tidsrum
har sekunder eller timer. I \pycsp kan man i en timeout planlægge en
begivenhed til at ske om f.eks. 5 sekunder. I \des findes sekunder som
begreb ikke, men man  angiver i stedet at når tiden er talt op med 5 abitræert enheder skal
begivenheden ske. Der findes dog ikke en totalt afkobling mellem tiden i \des og realtiden, for givet et konkret problem der skal modelleres i \des, vil der altid være en sammenhæng mellem tiderne. Men da der ikke findes en fast sammenhæng, skal denne defineres eksplicit af brugeren, som f.eks at 5 sekunder i problemet defineres som en stigning i tiden med f.eks 5, 0,5 eller 0,05 i simuleringsmodellen.

Når tiden i \des er uafhængig af realtiden er der ingen grund til at bruge en kompleks model af tiden og vi har derfor valgt at repræsentere tiden som et positivt tal der findes internt i \sched en. Ved at have tiden i  \sched en findes der kun en version af tiden da  \sched en er en singelton. For processer der ønsker at kende tiden har vi
introduceret funktionen \code{Now()} der returnerer tiden når funktionen kaldes. 

I den eksisterende \sched ~ er tiden reel og fremskrives derfor løbende uafhængigt af processernes tilstand. Dette kan illustreres med et eksempel; Proces 1 har startet en ny tråd via \code{io-decoratoren}, og er derfor blokeret. Proces 2 står i en \code{Alternation} med en timeout guard. Uafhængigt af tiden det tager proces 1 at komme ud fra sit blokerede kald, skal proces 2 vide når dens timeout er indtrådt. Dette er implementeret i \code{greenlets}-versionen i \cref{fig:blocking_sleep} på linjerne 242 til 251. For at køre disse linjer må  der findes processer der er blokeret samt processer der venter på en timeout. Nu startes en separat tråd der signalere \sched en, når næste begivenhed i \code{timers} listen indtræffer. \Sched en kan nu vente på et signal, som vil komme fra enten en blokeret proces eller den nyoprettede tråd.

I en simulering står tiden stille mens processerne  eksekveres, og kun i det tilfælde hvor der ikke findes nogle processer, der kan eksekveres vælger vi at tælle tiden op.  Den ekstra tråd til håndtering af tid i et blokeret kald er derfor overflødig i \des, for så længe der findes blokerede processer venter \sched en på dem, uden at tiden tælles op, da de potentielt senere vil kunne  generere nye processer der kan eksekveres.

Når alle processer venter i enten \code{timers} listen eller på kommunikation kan der ikke ske flere begivenheder før \sched en tæller tiden op. 
Vi kan i det tilfælde finde tidspunktet for den begivenhed der ligger tættets på den nuværende tidspunkt  og springe til det. Følgende er implementeret i \cref{fig:sim_sleep}.
\begin{figure}[hbtp]
\begin{minipage}[c]{\linewidth}
\begin{lstlisting}[firstnumber=239, label=fig:blocking_sleep, caption=Uddrag af \sched en i \code{Scheduler}]
self.cond.acquire()
if not (self.next or self.new):
    # Waiting on blocking processes or all processes have finished!
    if self.timers:
        # Set timer to lowest activation time
        seconds = self.timers[0][0] - time.time()
        if seconds > 0:
            t = threading.Timer(seconds, self.timer_notify)
            # We don't worry about cancelling, since it makes no 
            # difference if timer_notify is called one more time.
            t.start()
            # Now go to sleep
            self.cond.wait()
    elif self.blocking > 0:
        # Now go to sleep
        self.cond.wait()
    else:
        # Execution finished!
        self.cond.release()
        return
self.cond.release()
\end{lstlisting}
\end{minipage}
\begin{minipage}[c]{\linewidth}
\begin{lstlisting}[firstnumber=158, label=fig:sim_sleep, caption= uddrag af \sched en i \code{Simulation}]
self.cond.acquire()
if not (self.next or self.new):
  # Waiting on blocking processes
  if self.blocking > 0:
    # Now go to sleep
    self.cond.wait()
  #If there exist only processes in timers we can increment
  elif  not (self.next or self.new or self.blocking): 
      if self.timers:
          # inc timer to lowest activation time
          self._t = self.timers[0][0]
      else:
          # Execution finished!
          self.cond.release()
          return
self.cond.release()  
\end{lstlisting}
\end{minipage}
\end{figure}

\subsection{Timers}  
\CRef{sec:tid} viser at listen \code{timers} i \pycsp kun bruges til at placere processer der venter på en timeout i \code{alternation}. Dette er en niche feature ved \pycsp, som  sjældent vil skulle bruges, og hvor der sjældent er samlet mange processer på en gang. 
 I \cref{sec:Wait} beskriv vi hvordan processer der ønsker at vente ligges på \code{timers} listen, og i \cref{sec:discrete} beskriver vi hvordan \sched kun tæller tiden op når ingen processer kan foretage sig mere i et givent tidsskridt. Når tiden tælles op vil  alle processer enten vente på kommunikation eller befinde sig i listen \code{timers}. De processer der venter i en alternation og hvor der er tilknyttet en timeout vil ligge begge steder. Gennemsnitslængden af listen vil derfor stige voldsomt og dermed ændres kravene til hvilken  datastruktur der er bedst egnet. 
 
Med en kort, sjældent brugt liste vil omkostningerne til oprettelse og vedligeholdelse af en avanceret datastruktur være større end fordelene. Ved simuleringer ændres brugen af listen og vi skal derfor finde en datastruktur der bedre passer til vores brug. En min"-hob er det åbenlyse valg til skemaplanlægning da  man kan  indsætte elementer i konstant tid og fjerne det mindste element i $O(log\ n)$. Som eksempel på for anvendelsesmulighederne af en hob er skemaplanlægning specifikt nævnt i introduktionen til Pythons implementering\footnote{$http://docs.python.org/dev/3.0/library/heapq.html$}.  \fxnote{SB: rs, er det ok?}

Da en implementering af en hob allerede findes i Python i modulet \code{heapq}, som er effektivt implementeret i C, vælger vi at bruge denne. Den eneste handling
der ikke er som standard er implementeret, er fjernelsen af et arbitrært element.
fra hoben. Dette sker i den eksisterende løsning når en proces
aktivere et andet valg i \code{alternation} end timeout. I dette tilfælde skal
processen ikke vente på sin timeout, men elementet skal fjernes fra
\code{timers} listen. Her, må man som i
en normal liste lave en lineær søgning i hoben, og derefter genoprette
hob"-egenskaben i listen. Dette vil dog ikke tage længere tid, da en fjernelse af en timeout i \emph{greenlets}"-versionen på nuværende
tidspunkt bruger en lineær søgning, til at finde elementet der skal
fjernes, og genoprettelsen af hob"-egenskaben også kan gøres i lineær tid.

Det kræver ikke meget omskrivning for at konvertere en liste til en hob, men man kan sammenligne \cref{fig:green:timer} linje 205 med \cref{fig:sim:timer} linje 126. 


\subsection{Annekteret kode fra \simpy.}
I vores implementering findes der i sagens natur i overlap med \simpy, som har været en inspirationskilde til hvordan et simuleringssprog kunne udvikles i Python. En del af arbejdet med \simpy har vi kunne bruge direkte i vore implementering, efter devisen om ikke at genskrive eksisterende god kode. Det drejer sig om funktionalitet til dataindsamling, bearbejdning og visualisering. I \simpy findes en \code{Monitor}klasse. Formålet med denne klasse er at gemme en liste af tid/værdi par. Dermed kan man efter endt simulering, analysere  hvordan værdierne har ændret sig over tid. Klassen \code{Monitor} kan bruges direkte af brugere, hvor de så selv  står for at at gemme værdier på passende tidspunkter igennem kørslen af programmet. Man ønsker tit at kende længden af en kø, der som oftest er implementeret via en liste. Vi har derfor lavet vores egen liste der kan indeholde en \code{Monitor}. Når længden af listen ændres gemmes længden af listen i en montor til brug for senere analyse, uden brugeren selv skal stå for at gemme længden af listen. Alternativt kan man lave en separat proces hvis eneste formål der er med en given frekvens at gemme længden listen Fordelen ved denne løsning at er intervallet er jævnt fordelt, og man derfor lettere kan foretage tidsspecifik statistik.


